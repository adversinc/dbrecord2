"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MysqlDatabase = _interopRequireDefault(require("./MysqlDatabase2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strcount = require('quickly-count-substrings');
/**
 * Represents the database record class.
**/


class DbRecord2 {
  static _table() {
    throw "DbRecord can't be created directly";
  }

  static _locatefield() {
    throw "DbRecord can't be created directly";
  }

  static _keys() {
    return [];
  }
  /**
   * Creates the class instance. If options.${_locatefield()} parameter is specified,
   * reads the data from the database and put them into the internal structures
   * (see _init() and _read())
   * @param {Object} [options]
   * @param {Boolean} [options.forUpdate] - read record with FOR UPDATE flag,
   * 	blocking it within the transaction
   */


  constructor(options = {}) {
    /**
     * The database handler to work with
     */
    this._raw = {};
    this._changes = {};
    this._super = {}; // To hold the existing access method functions

    this._tableName = this.constructor._table();
    this._locateField = this.constructor._locatefield();
    this._options = Object.assign({}, options);
  }
  /**
   * Initialize class structures, read database
   * @returns {Promise<void>}
   */


  async init() {
    // Use either locally provided or database handler factory
    if (this._options.dbh) {
      this._dbh = this._options.dbh;
    } else {
      this._dbh = await this._getDbhClass().masterDbh();
    } //console.log("using trxDbh:", this._dbh.cid);


    await this._init(this._options);
  }
  /**
   * Tries creating an object by locate field/keys. Unlike constructor, does
   * not throw an error for non-existing record and returns null instead.
   * @param options
   */


  static async tryCreate(options = {}) {
    try {
      const obj = new this(options);
      await obj.init();
      return obj;
    } catch (ex) {
      if (ex.message == "E_DB_NO_OBJECT") {
        return null;
      } else {
        throw ex;
      }
    }
  }
  /**
   * Save accumulated changed fields, if any
   * @param {Object} options
   * @param {String} options.behavior - if "REPLACE", does "REPLACE INTO"
   */


  async commit(options = {}) {
    let sql = "";

    if (Object.keys(this._changes).length === 0) {
      return;
    }

    if (this._raw[this._locateField] !== undefined) {
      sql = "UPDATE ";
    } else if (options.behavior === "REPLACE") {
      sql = "REPLACE INTO ";
    } else {
      sql = "INSERT INTO ";
    }

    sql += `${this._tableName} SET `;
    const fields = [];
    const values = [];
    Object.keys(this._changes).forEach(field => {
      fields.push(field + "=?");
      values.push(this._raw[field]);
    });
    sql += fields.join(",");

    if (this._raw[this._locateField] !== undefined) {
      sql += ` WHERE ${this._locateField}=?`;
      values.push(this._raw[this._locateField]);
    } // Compare our dbh.cid and current transaction dbh


    const trxDbh = this._getDbhClass().masterDbhRO(); //console.log("Comparing dbh:", this._dbh.cid, trxDbh? trxDbh.cid: undefined);


    if (trxDbh) {
      if (this._dbh.cid !== trxDbh.cid) {
        throw new Error(`${this.constructor.name}: Object has to be re-created in transaction`);
      }
    }

    const res = await this._dbh.queryAsync(sql, values);
    this._changes = {}; // During the first insert the ${_locatefield()} field will be empty, and,
    // probably, generated by mysql

    if (this._raw[this._locateField] === undefined) {
      this._raw[this._locateField] = res.insertId;

      if (this[this._locateField] === undefined) {
        this._createAccessMethod(this._locateField);
      }
    }
  }
  /**
   * Initializes class from the database or as an empty record.
   *
   * If 'options' contains a property named as _locatefield() defines, then we
   * try to initialize from the database. Exception is thrown if there's no
   * record found.
   *
   * @param options
   * @protected
   */


  async _init(options) {
    let byKey = null;
    const keyArgs = [];

    this.constructor._keys().sort(commaSort).forEach(k => {
      // console.log("key", k);
      if (byKey != null) {
        return;
      } // Check if all key parts are present


      let fits = true;
      k.split(",").forEach(kpart => {
        if (!(kpart in options)) {
          fits = false;
        }
      });

      if (fits) {
        // Key fits, remember it and its arguments
        byKey = k.split(",");
        byKey.forEach(kpart => {
          keyArgs.push(options[kpart]);
        });
      }
    }); // if "_locateField" is set, then we need to read our data from the database


    if (this._locateField in options) {
      await this._read(options[this._locateField]);
    } else if (byKey) {
      await this._readByKey(byKey, keyArgs);
    } else {
      // else create a new record: read the table info and build access methods
      await this._initEmpty();
    }
  }
  /**
   * Reads values from the database, puts them into _raw and creates a function
   * to get each value, so we can access fields as:
   * obj.field();
   * obj.field("new value");
   * @protected
   * @param {*} locateValue - the database unique id of the record
   * @param {String} byKey - the field to search on. $_locateField by default.
   */


  async _read(locateValue, byKey) {
    let field = byKey || this._locateField;
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1 ${forUpdate}`, [locateValue]);
    return this._createFromRows(rows);
  }
  /**
   * Does the same work as _read, but accepts the secondary keys and values arrays
   * @param keys {Array}
   * @param values {Array}
   * @private
   */


  async _readByKey(keys, values) {
    const fields = keys.join("=? AND ") + "=?";
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${fields} LIMIT 1 ${forUpdate}`, values);
    return this._createFromRows(rows);
  }
  /**
   * Initialize object and methods			if(args.Length >= 1 && !UUID.TryParse(args[0], out folder)) {
  			return "FAIL: error parsing folder UUID";
  		}
   from rows array
   * @param rows
   * @private
   */


  _createFromRows(rows) {
    if (rows.length == 0) {
      throw new Error("E_DB_NO_OBJECT");
    }

    this._raw = rows[0]; // Create access methods for all fields

    Object.keys(this._raw).forEach(field => {
      this._createAccessMethod(field);
    });
  }
  /**
   * Initializes an empty object
   * @private
   */


  async _initEmpty() {
    const rows = await this._dbh.queryAsync(`DESCRIBE ${this._tableName}`);
    rows.forEach(field => {
      this._createAccessMethod(field.Field);
    });
  }
  /**
   * The template for access methods. Reads or sets the value of the object field.
   * @param field
   * @param value
   * @private
   */


  _accessField(field, value) {
    // To set NULL field: class.field(null)
    if (value !== undefined) {
      this._changes[field] = true;
      this._raw[field] = value;
    }

    return this._raw[field];
  }
  /**
   * Creates a function within this class to get/set the certain field
   * @param field
   * @private
   */


  _createAccessMethod(field) {
    //console.log("creating", field, typeof this[field]);
    const f = (value = undefined) => {
      return this._accessField(field, value);
    }; // If access function already exists, do not overwrite it. Instead, add a function
    // to this._super object


    if (typeof this[field] === "function") {
      this._super[field] = f;
    } else {
      this[field] = f;
    }
  }
  /**
   * Removes the record from the database. No verification or integrity checks
   * are being performed, they are up to caller.
   */


  async deleteRecord() {
    await this._dbh.queryAsync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`, [this[this._locateField]()]);
  }
  /**
   * Returns master database handle currently in-use. To be used in static
   * methods of DbRecord
   *
   * @returns {MysqlDatabase2} current mysql database connection class
   */


  static masterDbh() {
    return this._getDbhClassStatic().masterDbh();
  }
  /**
   * Runs through database objects according the options, and calls the
   * callback routine for each.
   *
   * @param {Object} options
   * @param {String} options.any_lowercase_field - the field to get added to WHERE
   * @param {[String]} options.whereCond - optional WHERE conditions to add
   * @param {[String]} options.whereParam - optional parameters for whereCond's
   * @param {Boolean} [options.forUpdate] - lock records for update
   * @param {String} [options.ORDERBY] - the sort field or expression
   * @param {String} [options.LIMIT] - the SQL LIMIT expression
   * @param {Boolean} [options.DEBUG_SQL_QUERY] - send SQL to console log
   * @param {Function} cb - the callback function, it receives two arguments:
   * 	the current iteration DbRecord and the "options" object
   *
   * @returns {Number} the number of rows found
   */


  static async forEach(options, cb) {
    const where = [];
    const qparam = [];

    const sql = this._prepareForEach(options, where, qparam); //
    // Iterate


    const _dbh = await this._getDbhClassStatic().masterDbh();

    const rows = await _dbh.queryAsync(sql, qparam);
    options.TOTAL = rows.length;

    if (cb) {
      options.COUNTER = 0;

      for (const row of rows) {
        options.COUNTER++;
        const o = {};
        o[this._locatefield()] = row[this._locatefield()];
        const obj = new this(o);
        await obj.init(); // Wait for iterator to end

        await cb(obj, options);
      }
    } else {
      options.COUNTER = options.TOTAL;
    }

    return options.COUNTER;
  }
  /**
   * Prepares SQL and param arrays for forEach()
   * @param options
   * @param where
   * @param qparam
   * @returns {string}
   * @private
   */


  static _prepareForEach(options, where, qparam) {
    let sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;

    if (options.forUpdate) {
      sql += " FOR UPDATE";
    } // WHERE fields


    Object.keys(options).forEach(k => {
      if (k.match(/[^a-z0-9._]/)) {
        return;
      }

      where.push(`${k}=?`);
      qparam.push(options[k]);
    });

    if (options.whereCond) {
      options.whereCond.forEach(q => {
        where.push(`(${q})`);
      });
    }

    if (options.whereParam) {
      options.whereParam.forEach(q => {
        qparam.push(q);
      });
    }

    if (where.length > 0) {
      sql += " WHERE " + where.join(" AND ");
    } // ORDER BY


    if (options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {
      sql += " ORDER BY " + options.ORDERBY;
    } // LIMIT


    if (options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {
      sql += " LIMIT " + options.LIMIT;
    }

    if (options.DEBUG_SQL_QUERY) {
      console.log(sql, qparam);
    }

    return sql;
  }
  /**
   * Starts a transaction and creates an instance of our object within that
   * transaction, passing it to the callback
   * @param {Function} cb - function to run with a "me" newly created objec
   * @returns {Promise<void>}
   */


  async transactionWithMe(cb) {
    const Class = this.constructor; // Make sure we are committed

    if (Object.keys(this._changes).length > 0) {
      throw new Error(`${Class.name}: Object has uncommitted changes before transaction`);
    }

    const dbh = await Class.masterDbh();
    await dbh.execTransactionAsync(async () => {
      const params = {};
      params[this._locateField] = this[this._locateField]();
      const me = new this.constructor(params);
      await me.init();
      return await cb(me);
    }); // Re-read our object after the transaction

    await this._read(this[this._locateField]());
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord class
   * @private
   */


  static _getDbhClassStatic() {
    return _MysqlDatabase.default;
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord object
   * @private
   */


  _getDbhClass() {
    return _MysqlDatabase.default;
  }

}
/**
 * The sorting function to get entries with more commas first
 * @param a
 * @param b
 */


exports.default = DbRecord2;

function commaSort(a, b) {
  const ca = strcount(a, ",");
  const cb = strcount(b, ",");
  return ca > cb ? -1 : 1;
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EYlJlY29yZDIuanMiXSwibmFtZXMiOlsic3RyY291bnQiLCJyZXF1aXJlIiwiRGJSZWNvcmQyIiwiX3RhYmxlIiwiX2xvY2F0ZWZpZWxkIiwiX2tleXMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfcmF3IiwiX2NoYW5nZXMiLCJfc3VwZXIiLCJfdGFibGVOYW1lIiwiX2xvY2F0ZUZpZWxkIiwiX29wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbml0IiwiZGJoIiwiX2RiaCIsIl9nZXREYmhDbGFzcyIsIm1hc3RlckRiaCIsIl9pbml0IiwidHJ5Q3JlYXRlIiwib2JqIiwiZXgiLCJtZXNzYWdlIiwiY29tbWl0Iiwic3FsIiwia2V5cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImJlaGF2aW9yIiwiZmllbGRzIiwidmFsdWVzIiwiZm9yRWFjaCIsImZpZWxkIiwicHVzaCIsImpvaW4iLCJ0cnhEYmgiLCJtYXN0ZXJEYmhSTyIsImNpZCIsIkVycm9yIiwibmFtZSIsInJlcyIsInF1ZXJ5QXN5bmMiLCJpbnNlcnRJZCIsIl9jcmVhdGVBY2Nlc3NNZXRob2QiLCJieUtleSIsImtleUFyZ3MiLCJzb3J0IiwiY29tbWFTb3J0IiwiayIsImZpdHMiLCJzcGxpdCIsImtwYXJ0IiwiX3JlYWQiLCJfcmVhZEJ5S2V5IiwiX2luaXRFbXB0eSIsImxvY2F0ZVZhbHVlIiwiZm9yVXBkYXRlIiwicm93cyIsIl9jcmVhdGVGcm9tUm93cyIsIkZpZWxkIiwiX2FjY2Vzc0ZpZWxkIiwidmFsdWUiLCJmIiwiZGVsZXRlUmVjb3JkIiwiX2dldERiaENsYXNzU3RhdGljIiwiY2IiLCJ3aGVyZSIsInFwYXJhbSIsIl9wcmVwYXJlRm9yRWFjaCIsIlRPVEFMIiwiQ09VTlRFUiIsInJvdyIsIm8iLCJtYXRjaCIsIndoZXJlQ29uZCIsInEiLCJ3aGVyZVBhcmFtIiwiT1JERVJCWSIsIkxJTUlUIiwidG9TdHJpbmciLCJERUJVR19TUUxfUVVFUlkiLCJjb25zb2xlIiwibG9nIiwidHJhbnNhY3Rpb25XaXRoTWUiLCJDbGFzcyIsImV4ZWNUcmFuc2FjdGlvbkFzeW5jIiwicGFyYW1zIiwibWUiLCJNeXNxbERhdGFiYXNlMiIsImEiLCJiIiwiY2EiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBLE1BQU1BLFFBQVEsR0FBR0MsT0FBTyxDQUFDLDBCQUFELENBQXhCO0FBRUE7Ozs7O0FBR2UsTUFBTUMsU0FBTixDQUFnQjtBQUM5QixTQUFPQyxNQUFQLEdBQWdCO0FBQUUsVUFBTSxvQ0FBTjtBQUE2Qzs7QUFDL0QsU0FBT0MsWUFBUCxHQUFzQjtBQUFFLFVBQU0sb0NBQU47QUFBNkM7O0FBQ3JFLFNBQU9DLEtBQVAsR0FBZTtBQUFFLFdBQU8sRUFBUDtBQUFZO0FBRTdCOzs7Ozs7Ozs7O0FBUUFDLEVBQUFBLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHLEVBQVgsRUFBZTtBQUN6Qjs7O0FBR0EsU0FBS0MsSUFBTCxHQUFZLEVBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEVBQWQsQ0FOeUIsQ0FNUDs7QUFFbEIsU0FBS0MsVUFBTCxHQUFrQixLQUFLTCxXQUFMLENBQWlCSCxNQUFqQixFQUFsQjtBQUNBLFNBQUtTLFlBQUwsR0FBb0IsS0FBS04sV0FBTCxDQUFpQkYsWUFBakIsRUFBcEI7QUFFQSxTQUFLUyxRQUFMLEdBQWdCQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCUixPQUFsQixDQUFoQjtBQUNBO0FBRUQ7Ozs7OztBQUlBLFFBQU1TLElBQU4sR0FBYTtBQUNaO0FBQ0EsUUFBRyxLQUFLSCxRQUFMLENBQWNJLEdBQWpCLEVBQXNCO0FBQ3JCLFdBQUtDLElBQUwsR0FBWSxLQUFLTCxRQUFMLENBQWNJLEdBQTFCO0FBQ0EsS0FGRCxNQUVPO0FBQ04sV0FBS0MsSUFBTCxHQUFZLE1BQU0sS0FBS0MsWUFBTCxHQUFvQkMsU0FBcEIsRUFBbEI7QUFDQSxLQU5XLENBUVo7OztBQUVBLFVBQU0sS0FBS0MsS0FB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QSxTQUFPQyxFQUFFLEdBQUMxQixFQUFILEdBQU8sQ0FBQyxDQUFSLEdBQVksQ0FBbkI7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNeXNxbERhdGFiYXNlMiBmcm9tIFwiLi9NeXNxbERhdGFiYXNlMlwiO1xuY29uc3Qgc3RyY291bnQgPSByZXF1aXJlKCdxdWlja2x5LWNvdW50LXN1YnN0cmluZ3MnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhYmFzZSByZWNvcmQgY2xhc3MuXG4qKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERiUmVjb3JkMiB7XG5cdHN0YXRpYyBfdGFibGUoKSB7IHRocm93IFwiRGJSZWNvcmQgY2FuJ3QgYmUgY3JlYXRlZCBkaXJlY3RseVwiOyB9XG5cdHN0YXRpYyBfbG9jYXRlZmllbGQoKSB7IHRocm93IFwiRGJSZWNvcmQgY2FuJ3QgYmUgY3JlYXRlZCBkaXJlY3RseVwiOyB9XG5cdHN0YXRpYyBfa2V5cygpIHsgcmV0dXJuIFtdOyB9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIGNsYXNzIGluc3RhbmNlLiBJZiBvcHRpb25zLiR7X2xvY2F0ZWZpZWxkKCl9IHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsXG5cdCAqIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFiYXNlIGFuZCBwdXQgdGhlbSBpbnRvIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmVzXG5cdCAqIChzZWUgX2luaXQoKSBhbmQgX3JlYWQoKSlcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvclVwZGF0ZV0gLSByZWFkIHJlY29yZCB3aXRoIEZPUiBVUERBVEUgZmxhZyxcblx0ICogXHRibG9ja2luZyBpdCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHQvKipcblx0XHQgKiBUaGUgZGF0YWJhc2UgaGFuZGxlciB0byB3b3JrIHdpdGhcblx0XHQgKi9cblx0XHR0aGlzLl9yYXcgPSB7fTtcblx0XHR0aGlzLl9jaGFuZ2VzID0ge307XG5cdFx0dGhpcy5fc3VwZXIgPSB7fTsgLy8gVG8gaG9sZCB0aGUgZXhpc3RpbmcgYWNjZXNzIG1ldGhvZCBmdW5jdGlvbnNcblxuXHRcdHRoaXMuX3RhYmxlTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuX3RhYmxlKCk7XG5cdFx0dGhpcy5fbG9jYXRlRmllbGQgPSB0aGlzLmNvbnN0cnVjdG9yLl9sb2NhdGVmaWVsZCgpO1xuXG5cdFx0dGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgY2xhc3Mgc3RydWN0dXJlcywgcmVhZCBkYXRhYmFzZVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIGluaXQoKSB7XG5cdFx0Ly8gVXNlIGVpdGhlciBsb2NhbGx5IHByb3ZpZGVkIG9yIGRhdGFiYXNlIGhhbmRsZXIgZmFjdG9yeVxuXHRcdGlmKHRoaXMuX29wdGlvbnMuZGJoKSB7XG5cdFx0XHR0aGlzLl9kYmggPSB0aGlzLl9vcHRpb25zLmRiaDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZGJoID0gYXdhaXQgdGhpcy5fZ2V0RGJoQ2xhc3MoKS5tYXN0ZXJEYmgoKTtcblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKFwidXNpbmcgdHJ4RGJoOlwiLCB0aGlzLl9kYmguY2lkKTtcblxuXHRcdGF3YWl0IHRoaXMuX2luaXQodGhpcy5fb3B0aW9ucyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBUcmllcyBjcmVhdGluZyBhbiBvYmplY3QgYnkgbG9jYXRlIGZpZWxkL2tleXMuIFVubGlrZSBjb25zdHJ1Y3RvciwgZG9lc1xuXHQgKiBub3QgdGhyb3cgYW4gZXJyb3IgZm9yIG5vbi1leGlzdGluZyByZWNvcmQgYW5kIHJldHVybnMgbnVsbCBpbnN0ZWFkLlxuXHQgKiBAcGFyYW0gb3B0aW9uc1xuXHQgKi9cblx0c3RhdGljIGFzeW5jIHRyeUNyZWF0ZShvcHRpb25zID0ge30pIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgb2JqID0gbmV3IHRoaXMob3B0aW9ucyk7XG5cdFx0XHRhd2FpdCBvYmouaW5pdCgpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRpZihleC5tZXNzYWdlID09IFwiRV9EQl9OT19PQkpFQ1RcIikgeyByZXR1cm4gbnVsbDsgfVxuXHRcdFx0ZWxzZSB7IHRocm93IGV4OyB9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNhdmUgYWNjdW11bGF0ZWQgY2hhbmdlZCBmaWVsZHMsIGlmIGFueVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5iZWhhdmlvciAtIGlmIFwiUkVQTEFDRVwiLCBkb2VzIFwiUkVQTEFDRSBJTlRPXCJcblx0ICovXG5cdGFzeW5jIGNvbW1pdChvcHRpb25zID0ge30pIHtcblx0XHRsZXQgc3FsID0gXCJcIjtcblxuXHRcdGlmKE9iamVjdC5rZXlzKHRoaXMuX2NoYW5nZXMpLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3FsID0gXCJVUERBVEUgXCI7XG5cdFx0fSBlbHNlIGlmKG9wdGlvbnMuYmVoYXZpb3IgPT09IFwiUkVQTEFDRVwiKSB7XG5cdFx0XHRzcWwgPSBcIlJFUExBQ0UgSU5UTyBcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3FsID0gXCJJTlNFUlQgSU5UTyBcIjtcblx0XHR9XG5cblx0XHRzcWwgKz0gYCR7dGhpcy5fdGFibGVOYW1lfSBTRVQgYDtcblx0XHRjb25zdCBmaWVsZHMgPSBbXTtcblx0XHRjb25zdCB2YWx1ZXMgPSBbXTtcblx0XHRPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VzKS5mb3JFYWNoKChmaWVsZCkgPT4ge1xuXHRcdFx0ZmllbGRzLnB1c2goZmllbGQgKyBcIj0/XCIpO1xuXHRcdFx0dmFsdWVzLnB1c2godGhpcy5fcmF3W2ZpZWxkXSk7XG5cdFx0fSk7XG5cblx0XHRzcWwgKz0gZmllbGRzLmpvaW4oXCIsXCIpO1xuXG5cdFx0aWYodGhpcy5fcmF3W3RoaXMuX2xvY2F0ZUZpZWxkXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRzcWwgKz0gYCBXSEVSRSAke3RoaXMuX2xvY2F0ZUZpZWxkfT0/YDtcblx0XHRcdHZhbHVlcy5wdXNoKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0pO1xuXHRcdH1cblxuXHRcdC8vIENvbXBhcmUgb3VyIGRiaC5jaWQgYW5kIGN1cnJlbnQgdHJhbnNhY3Rpb24gZGJoXG5cdFx0Y29uc3QgdHJ4RGJoID0gdGhpcy5fZ2V0RGJoQ2xhc3MoKS5tYXN0ZXJEYmhSTygpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIkNvbXBhcmluZyBkYmg6XCIsIHRoaXMuX2RiaC5jaWQsIHRyeERiaD8gdHJ4RGJoLmNpZDogdW5kZWZpbmVkKTtcblxuXHRcdGlmKHRyeERiaCkge1xuXHRcdFx0aWYodGhpcy5fZGJoLmNpZCAhPT0gdHJ4RGJoLmNpZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogT2JqZWN0IGhhcyB0byBiZSByZS1jcmVhdGVkIGluIHRyYW5zYWN0aW9uYCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoVEFSR0VUID09PSBcImRldmVsb3BtZW50XCIpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGAke3RoaXMuX2RiaC5fZGIudGhyZWFkSWR9OiBpbiBjb21taXQgYmVmb3JlIHF1ZXJ5YCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoc3FsLCB2YWx1ZXMpO1xuXG5cdFx0dGhpcy5fY2hhbmdlcyA9IHt9O1xuXG5cdFx0Ly8gRHVyaW5nIHRoZSBmaXJzdCBpbnNlcnQgdGhlICR7X2xvY2F0ZWZpZWxkKCl9IGZpZWxkIHdpbGwgYmUgZW1wdHksIGFuZCxcblx0XHQvLyBwcm9iYWJseSwgZ2VuZXJhdGVkIGJ5IG15c3FsXG5cdFx0aWYodGhpcy5fcmF3W3RoaXMuX2xvY2F0ZUZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9yYXdbdGhpcy5fbG9jYXRlRmllbGRdID0gcmVzLmluc2VydElkO1xuXG5cdFx0XHRpZih0aGlzW3RoaXMuX2xvY2F0ZUZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX2NyZWF0ZUFjY2Vzc01ldGhvZCh0aGlzLl9sb2NhdGVGaWVsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGNsYXNzIGZyb20gdGhlIGRhdGFiYXNlIG9yIGFzIGFuIGVtcHR5IHJlY29yZC5cblx0ICpcblx0ICogSWYgJ29wdGlvbnMnIGNvbnRhaW5zIGEgcHJvcGVydHkgbmFtZWQgYXMgX2xvY2F0ZWZpZWxkKCkgZGVmaW5lcywgdGhlbiB3ZVxuXHQgKiB0cnkgdG8gaW5pdGlhbGl6ZSBmcm9tIHRoZSBkYXRhYmFzZS4gRXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGVyZSdzIG5vXG5cdCAqIHJlY29yZCBmb3VuZC5cblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YXN5bmMgX2luaXQob3B0aW9ucykge1xuXHRcdGxldCBieUtleSA9IG51bGw7XG5cdFx0Y29uc3Qga2V5QXJncyA9IFtdO1xuXG5cdFx0dGhpcy5jb25zdHJ1Y3Rvci5fa2V5cygpLnNvcnQoY29tbWFTb3J0KS5mb3JFYWNoKChrKSA9PiB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcImtleVwiLCBrKTtcblx0XHRcdGlmKGJ5S2V5ICE9IG51bGwpIHsgcmV0dXJuOyB9XG5cblx0XHRcdC8vIENoZWNrIGlmIGFsbCBrZXkgcGFydHMgYXJlIHByZXNlbnRcblx0XHRcdGxldCBmaXRzID0gdHJ1ZTtcblx0XHRcdGsuc3BsaXQoXCIsXCIpLmZvckVhY2goKGtwYXJ0KSA9PiB7XG5cdFx0XHRcdGlmKCEoa3BhcnQgaW4gb3B0aW9ucykpIHsgZml0cyA9IGZhbHNlOyB9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYoZml0cykge1xuXHRcdFx0XHQvLyBLZXkgZml0cywgcmVtZW1iZXIgaXQgYW5kIGl0cyBhcmd1bWVudHNcblx0XHRcdFx0YnlLZXkgPSBrLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0YnlLZXkuZm9yRWFjaCgoa3BhcnQpID0+IHtcblx0XHRcdFx0XHRrZXlBcmdzLnB1c2gob3B0aW9uc1trcGFydF0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGlmIFwiX2xvY2F0ZUZpZWxkXCIgaXMgc2V0LCB0aGVuIHdlIG5lZWQgdG8gcmVhZCBvdXIgZGF0YSBmcm9tIHRoZSBkYXRhYmFzZVxuXHRcdGlmKHRoaXMuX2xvY2F0ZUZpZWxkIGluIG9wdGlvbnMpIHtcblx0XHRcdGF3YWl0IHRoaXMuX3JlYWQob3B0aW9uc1t0aGlzLl9sb2NhdGVGaWVsZF0pO1xuXHRcdH1cblx0XHRlbHNlIGlmKGJ5S2V5KSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9yZWFkQnlLZXkoYnlLZXksIGtleUFyZ3MpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGVsc2UgY3JlYXRlIGEgbmV3IHJlY29yZDogcmVhZCB0aGUgdGFibGUgaW5mbyBhbmQgYnVpbGQgYWNjZXNzIG1ldGhvZHNcblx0XHRcdGF3YWl0IHRoaXMuX2luaXRFbXB0eSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyB2YWx1ZXMgZnJvbSB0aGUgZGF0YWJhc2UsIHB1dHMgdGhlbSBpbnRvIF9yYXcgYW5kIGNyZWF0ZXMgYSBmdW5jdGlvblxuXHQgKiB0byBnZXQgZWFjaCB2YWx1ZSwgc28gd2UgY2FuIGFjY2VzcyBmaWVsZHMgYXM6XG5cdCAqIG9iai5maWVsZCgpO1xuXHQgKiBvYmouZmllbGQoXCJuZXcgdmFsdWVcIik7XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHsqfSBsb2NhdGVWYWx1ZSAtIHRoZSBkYXRhYmFzZSB1bmlxdWUgaWQgb2YgdGhlIHJlY29yZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYnlLZXkgLSB0aGUgZmllbGQgdG8gc2VhcmNoIG9uLiAkX2xvY2F0ZUZpZWxkIGJ5IGRlZmF1bHQuXG5cdCAqL1xuXHRhc3luYyBfcmVhZChsb2NhdGVWYWx1ZSwgYnlLZXkpIHtcblx0XHRsZXQgZmllbGQgPSBieUtleSB8fCB0aGlzLl9sb2NhdGVGaWVsZDtcblx0XHRjb25zdCBmb3JVcGRhdGUgPSB0aGlzLl9vcHRpb25zLmZvclVwZGF0ZT8gXCJGT1IgVVBEQVRFXCI6IFwiXCI7XG5cblx0XHRjb25zdCByb3dzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYFNFTEVDVCAqIEZST00gJHt0aGlzLl90YWJsZU5hbWV9IFdIRVJFICR7ZmllbGR9PT8gTElNSVQgMSAke2ZvclVwZGF0ZX1gLFxuXHRcdFx0W2xvY2F0ZVZhbHVlXSk7XG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21Sb3dzKHJvd3MpO1xuXHR9XG5cblxuXHQvKipcblx0ICogRG9lcyB0aGUgc2FtZSB3b3JrIGFzIF9yZWFkLCBidXQgYWNjZXB0cyB0aGUgc2Vjb25kYXJ5IGtleXMgYW5kIHZhbHVlcyBhcnJheXNcblx0ICogQHBhcmFtIGtleXMge0FycmF5fVxuXHQgKiBAcGFyYW0gdmFsdWVzIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFzeW5jIF9yZWFkQnlLZXkoa2V5cywgdmFsdWVzKSB7XG5cdFx0Y29uc3QgZmllbGRzID0ga2V5cy5qb2luKFwiPT8gQU5EIFwiKSArIFwiPT9cIjtcblx0XHRjb25zdCBmb3JVcGRhdGUgPSB0aGlzLl9vcHRpb25zLmZvclVwZGF0ZT8gXCJGT1IgVVBEQVRFXCI6IFwiXCI7XG5cblx0XHRjb25zdCByb3dzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYFNFTEVDVCAqIEZST00gJHt0aGlzLl90YWJsZU5hbWV9IFdIRVJFICR7ZmllbGRzfSBMSU1JVCAxICR7Zm9yVXBkYXRlfWAsXG5cdFx0XHR2YWx1ZXMpO1xuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUm93cyhyb3dzKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgb2JqZWN0IGFuZCBtZXRob2RzXHRcdFx0aWYoYXJncy5MZW5ndGggPj0gMSAmJiAhVVVJRC5UcnlQYXJzZShhcmdzWzBdLCBvdXQgZm9sZGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gXCJGQUlMOiBlcnJvciBwYXJzaW5nIGZvbGRlciBVVUlEXCI7XG5cdFx0XHR9XG5cdCBmcm9tIHJvd3MgYXJyYXlcblx0ICogQHBhcmFtIHJvd3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGVGcm9tUm93cyhyb3dzKSB7XG5cdFx0aWYocm93cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRV9EQl9OT19PQkpFQ1RcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmF3ID0gcm93c1swXTtcblxuXHRcdC8vIENyZWF0ZSBhY2Nlc3MgbWV0aG9kcyBmb3IgYWxsIGZpZWxkc1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuX3JhdykuZm9yRWFjaCgoZmllbGQpID0+IHsgdGhpcy5fY3JlYXRlQWNjZXNzTWV0aG9kKGZpZWxkKTsgfSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW4gZW1wdHkgb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhc3luYyBfaW5pdEVtcHR5KCkge1xuXHRcdGNvbnN0IHJvd3MgPSBhd2FpdCB0aGlzLl9kYmgucXVlcnlBc3luYyhgREVTQ1JJQkUgJHt0aGlzLl90YWJsZU5hbWV9YCk7XG5cdFx0cm93cy5mb3JFYWNoKChmaWVsZCkgPT4geyB0aGlzLl9jcmVhdGVBY2Nlc3NNZXRob2QoZmllbGQuRmllbGQpOyB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdGVtcGxhdGUgZm9yIGFjY2VzcyBtZXRob2RzLiBSZWFkcyBvciBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0IGZpZWxkLlxuXHQgKiBAcGFyYW0gZmllbGRcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYWNjZXNzRmllbGQoZmllbGQsIHZhbHVlKSB7XG5cdFx0Ly8gVG8gc2V0IE5VTEwgZmllbGQ6IGNsYXNzLmZpZWxkKG51bGwpXG5cdFx0aWYodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fY2hhbmdlc1tmaWVsZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5fcmF3W2ZpZWxkXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9yYXdbZmllbGRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aXRoaW4gdGhpcyBjbGFzcyB0byBnZXQvc2V0IHRoZSBjZXJ0YWluIGZpZWxkXG5cdCAqIEBwYXJhbSBmaWVsZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZUFjY2Vzc01ldGhvZChmaWVsZCkge1xuXHRcdC8vY29uc29sZS5sb2coXCJjcmVhdGluZ1wiLCBmaWVsZCwgdHlwZW9mIHRoaXNbZmllbGRdKTtcblx0XHRjb25zdCBmID0gKHZhbHVlID0gdW5kZWZpbmVkKSA9PiB7IHJldHVybiB0aGlzLl9hY2Nlc3NGaWVsZChmaWVsZCwgdmFsdWUpOyB9O1xuXG5cdFx0Ly8gSWYgYWNjZXNzIGZ1bmN0aW9uIGFscmVhZHkgZXhpc3RzLCBkbyBub3Qgb3ZlcndyaXRlIGl0LiBJbnN0ZWFkLCBhZGQgYSBmdW5jdGlvblxuXHRcdC8vIHRvIHRoaXMuX3N1cGVyIG9iamVjdFxuXHRcdGlmKHR5cGVvZiB0aGlzW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0aGlzLl9zdXBlcltmaWVsZF0gPSBmO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2ZpZWxkXSA9IGY7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgcmVjb3JkIGZyb20gdGhlIGRhdGFiYXNlLiBObyB2ZXJpZmljYXRpb24gb3IgaW50ZWdyaXR5IGNoZWNrc1xuXHQgKiBhcmUgYmVpbmcgcGVyZm9ybWVkLCB0aGV5IGFyZSB1cCB0byBjYWxsZXIuXG5cdCAqL1xuXHRhc3luYyBkZWxldGVSZWNvcmQoKSB7XG5cdFx0YXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYERFTEVURSBGUk9NICR7dGhpcy5fdGFibGVOYW1lfSBXSEVSRSAke3RoaXMuX2xvY2F0ZUZpZWxkfSA9ID9gLFxuXHRcdFx0WyB0aGlzW3RoaXMuX2xvY2F0ZUZpZWxkXSgpIF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgbWFzdGVyIGRhdGFiYXNlIGhhbmRsZSBjdXJyZW50bHkgaW4tdXNlLiBUbyBiZSB1c2VkIGluIHN0YXRpY1xuXHQgKiBtZXRob2RzIG9mIERiUmVjb3JkXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtNeXNxbERhdGFiYXNlMn0gY3VycmVudCBteXNxbCBkYXRhYmFzZSBjb25uZWN0aW9uIGNsYXNzXG5cdCAqL1xuXHRzdGF0aWMgbWFzdGVyRGJoKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXREYmhDbGFzc1N0YXRpYygpLm1hc3RlckRiaCgpO1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBSdW5zIHRocm91Z2ggZGF0YWJhc2Ugb2JqZWN0cyBhY2NvcmRpbmcgdGhlIG9wdGlvbnMsIGFuZCBjYWxscyB0aGVcblx0ICogY2FsbGJhY2sgcm91dGluZSBmb3IgZWFjaC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYW55X2xvd2VyY2FzZV9maWVsZCAtIHRoZSBmaWVsZCB0byBnZXQgYWRkZWQgdG8gV0hFUkVcblx0ICogQHBhcmFtIHtbU3RyaW5nXX0gb3B0aW9ucy53aGVyZUNvbmQgLSBvcHRpb25hbCBXSEVSRSBjb25kaXRpb25zIHRvIGFkZFxuXHQgKiBAcGFyYW0ge1tTdHJpbmddfSBvcHRpb25zLndoZXJlUGFyYW0gLSBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB3aGVyZUNvbmQnc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvclVwZGF0ZV0gLSBsb2NrIHJlY29yZHMgZm9yIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuT1JERVJCWV0gLSB0aGUgc29ydCBmaWVsZCBvciBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5MSU1JVF0gLSB0aGUgU1FMIExJTUlUIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ERUJVR19TUUxfUVVFUlldIC0gc2VuZCBTUUwgdG8gY29uc29sZSBsb2dcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIGl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG5cdCAqIFx0dGhlIGN1cnJlbnQgaXRlcmF0aW9uIERiUmVjb3JkIGFuZCB0aGUgXCJvcHRpb25zXCIgb2JqZWN0XG5cdCAqXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyBmb3VuZFxuXHQgKi9cblx0c3RhdGljIGFzeW5jIGZvckVhY2gob3B0aW9ucywgY2IpIHtcblx0XHRjb25zdCB3aGVyZSA9IFtdO1xuXHRcdGNvbnN0IHFwYXJhbSA9IFtdO1xuXHRcdGNvbnN0IHNxbCA9IHRoaXMuX3ByZXBhcmVGb3JFYWNoKG9wdGlvbnMsIHdoZXJlLCBxcGFyYW0pO1xuXG5cdFx0Ly9cblx0XHQvLyBJdGVyYXRlXG5cdFx0Y29uc3QgX2RiaCA9IGF3YWl0IHRoaXMuX2dldERiaENsYXNzU3RhdGljKCkubWFzdGVyRGJoKCk7XG5cblx0XHRpZihUQVJHRVQgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuXHRcdFx0Y29uc29sZS5sb2coYCR7X2RiaC5fZGIudGhyZWFkSWR9OiB3aWxsIGJlIHJ1bm5pbmcgZm9yRWFjaCBxdWVyeWApO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvd3MgPSBhd2FpdCBfZGJoLnF1ZXJ5QXN5bmMoc3FsLCBxcGFyYW0pO1xuXHRcdG9wdGlvbnMuVE9UQUwgPSByb3dzLmxlbmd0aDtcblxuXHRcdGlmKGNiKSB7XG5cdFx0XHRvcHRpb25zLkNPVU5URVIgPSAwO1xuXG5cdFx0XHRmb3IoY29uc3Qgcm93IG9mIHJvd3MpIHtcblx0XHRcdFx0b3B0aW9ucy5DT1VOVEVSKys7XG5cblx0XHRcdFx0Y29uc3QgbyA9IHt9O1xuXHRcdFx0XHRvW3RoaXMuX2xvY2F0ZWZpZWxkKCldID0gcm93W3RoaXMuX2xvY2F0ZWZpZWxkKCldO1xuXHRcdFx0XHRjb25zdCBvYmogPSBuZXcgdGhpcyhvKTtcblx0XHRcdFx0YXdhaXQgb2JqLmluaXQoKTtcblxuXHRcdFx0XHQvLyBXYWl0IGZvciBpdGVyYXRvciB0byBlbmRcblx0XHRcdFx0YXdhaXQgY2Iob2JqLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5DT1VOVEVSID0gb3B0aW9ucy5UT1RBTDtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucy5DT1VOVEVSO1xuXHR9XG5cblxuXHQvKipcblx0ICogUHJlcGFyZXMgU1FMIGFuZCBwYXJhbSBhcnJheXMgZm9yIGZvckVhY2goKVxuXHQgKiBAcGFyYW0gb3B0aW9uc1xuXHQgKiBAcGFyYW0gd2hlcmVcblx0ICogQHBhcmFtIHFwYXJhbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhdGljIF9wcmVwYXJlRm9yRWFjaChvcHRpb25zLCB3aGVyZSwgcXBhcmFtKSB7XG5cdFx0bGV0IHNxbCA9IGBTRUxFQ1QgJHt0aGlzLl9sb2NhdGVmaWVsZCgpfSBGUk9NICR7dGhpcy5fdGFibGUoKX1gO1xuXHRcdGlmKG9wdGlvbnMuZm9yVXBkYXRlKSB7IHNxbCArPSBcIiBGT1IgVVBEQVRFXCI7IH1cblxuXG5cdFx0Ly8gV0hFUkUgZmllbGRzXG5cdFx0T2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCgoaykgPT4ge1xuXHRcdFx0aWYoay5tYXRjaCgvW15hLXowLTkuX10vKSkgeyByZXR1cm47IH1cblxuXHRcdFx0d2hlcmUucHVzaChgJHtrfT0/YCk7XG5cdFx0XHRxcGFyYW0ucHVzaChvcHRpb25zW2tdKTtcblx0XHR9KTtcblxuXHRcdGlmKG9wdGlvbnMud2hlcmVDb25kKSB7XG5cdFx0XHRvcHRpb25zLndoZXJlQ29uZC5mb3JFYWNoKChxKSA9PiB7XG5cdFx0XHRcdHdoZXJlLnB1c2goYCgke3F9KWApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYob3B0aW9ucy53aGVyZVBhcmFtKSB7XG5cdFx0XHRvcHRpb25zLndoZXJlUGFyYW0uZm9yRWFjaCgocSkgPT4ge1xuXHRcdFx0XHRxcGFyYW0ucHVzaChxKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmKHdoZXJlLmxlbmd0aCA+IDApIHtcblx0XHRcdHNxbCArPSBcIiBXSEVSRSBcIiArIHdoZXJlLmpvaW4oXCIgQU5EIFwiKTtcblx0XHR9XG5cblxuXHRcdC8vIE9SREVSIEJZXG5cdFx0aWYob3B0aW9ucy5PUkRFUkJZICYmICFvcHRpb25zLk9SREVSQlkubWF0Y2goL1teYS16QS1aMC05ID48LV0vKSkge1xuXHRcdFx0c3FsICs9IFwiIE9SREVSIEJZIFwiICsgb3B0aW9ucy5PUkRFUkJZO1xuXHRcdH1cblxuXHRcdC8vIExJTUlUXG5cdFx0aWYob3B0aW9ucy5MSU1JVCAmJiAhb3B0aW9ucy5MSU1JVC50b1N0cmluZygpLm1hdGNoKC9bXjAtOSwgXS8pKSB7XG5cdFx0XHRzcWwgKz0gXCIgTElNSVQgXCIgKyBvcHRpb25zLkxJTUlUO1xuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMuREVCVUdfU1FMX1FVRVJZKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhzcWwsIHFwYXJhbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNxbDtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIG91ciBvYmplY3Qgd2l0aGluIHRoYXRcblx0ICogdHJhbnNhY3Rpb24sIHBhc3NpbmcgaXQgdG8gdGhlIGNhbGxiYWNrXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gZnVuY3Rpb24gdG8gcnVuIHdpdGggYSBcIm1lXCIgbmV3bHkgY3JlYXRlZCBvYmplY1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIHRyYW5zYWN0aW9uV2l0aE1lKGNiKSB7XG5cdFx0Y29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIGFyZSBjb21taXR0ZWRcblx0XHRpZihPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VzKS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7Q2xhc3MubmFtZX06IE9iamVjdCBoYXMgdW5jb21taXR0ZWQgY2hhbmdlcyBiZWZvcmUgdHJhbnNhY3Rpb25gKTtcblx0XHR9XG5cblx0XHRjb25zdCBkYmggPSBhd2FpdCBDbGFzcy5tYXN0ZXJEYmgoKTtcblx0XHRhd2FpdCBkYmguZXhlY1RyYW5zYWN0aW9uQXN5bmMoYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0XHRwYXJhbXNbdGhpcy5fbG9jYXRlRmllbGRdID0gdGhpc1t0aGlzLl9sb2NhdGVGaWVsZF0oKTtcblx0XHRcdGNvbnN0IG1lID0gbmV3IHRoaXMuY29uc3RydWN0b3IocGFyYW1zKTtcblx0XHRcdGF3YWl0IG1lLmluaXQoKTtcblxuXHRcdFx0cmV0dXJuIGF3YWl0IGNiKG1lKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlLXJlYWQgb3VyIG9iamVjdCBhZnRlciB0aGUgdHJhbnNhY3Rpb25cblx0XHRhd2FpdCB0aGlzLl9yZWFkKHRoaXNbdGhpcy5fbG9jYXRlRmllbGRdKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgTXlzcWxEYXRhYmFzZSBjbGFzcyB1c2VkIGZvciB0aGlzIERiUmVjb3JkIGNsYXNzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgX2dldERiaENsYXNzU3RhdGljKCkge1xuXHRcdHJldHVybiBNeXNxbERhdGFiYXNlMjtcblx0fVxuXHQvKipcblx0ICogUmV0dXJucyBNeXNxbERhdGFiYXNlIGNsYXNzIHVzZWQgZm9yIHRoaXMgRGJSZWNvcmQgb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0RGJoQ2xhc3MoKSB7XG5cdFx0cmV0dXJuIE15c3FsRGF0YWJhc2UyO1xuXHR9XG59XG5cblxuLyoqXG4gKiBUaGUgc29ydGluZyBmdW5jdGlvbiB0byBnZXQgZW50cmllcyB3aXRoIG1vcmUgY29tbWFzIGZpcnN0XG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqL1xuZnVuY3Rpb24gY29tbWFTb3J0KGEsYikge1xuXHRjb25zdCBjYSA9IHN0cmNvdW50KGEsIFwiLFwiKTtcblx0Y29uc3QgY2IgPSBzdHJjb3VudChiLCBcIixcIik7XG5cdHJldHVybiBjYT5jYj8gLTEgOiAxO1xufVxuIl19