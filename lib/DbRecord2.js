"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MysqlDatabase = _interopRequireDefault(require("./MysqlDatabase2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strcount = require('quickly-count-substrings');
/**
 * Represents the database record class.
**/


class DbRecord2 {
  static _table() {
    throw "DbRecord can't be created directly";
  }

  static _locatefield() {
    throw "DbRecord can't be created directly";
  }

  static _keys() {
    return [];
  }
  /**
   * Creates the class instance. If options.${_locatefield()} parameter is specified,
   * reads the data from the database and put them into the internal structures
   * (see _init() and _read())
   * @param {Object} [options]
   * @param {Boolean} [options.forUpdate] - read record with FOR UPDATE flag,
   * 	blocking it within the transaction
   */


  constructor(options = {}) {
    /**
     * The database handler to work with
     */
    this._raw = {};
    this._changes = {};
    this._super = {}; // To hold the existing access method functions

    this._tableName = this.constructor._table();
    this._locateField = this.constructor._locatefield();
    this._options = Object.assign({}, options);
  }
  /**
   * Initialize class structures, read database
   * @returns {Promise<void>}
   */


  async init() {
    // Use either locally provided or database handler factory
    if (this._options.dbh) {
      this._dbh = this._options.dbh;
    } else {
      this._dbh = await this._getDbhClass().masterDbh();
    } //console.log("using trxDbh:", this._dbh.cid);


    await this._init(this._options);
  }
  /**
   * Tries creating an object by locate field/keys. Unlike constructor, does
   * not throw an error for non-existing record and returns null instead.
   * @param options
   */


  static async tryCreate(options = {}) {
    try {
      const obj = new this(options);
      await obj.init();
      return obj;
    } catch (ex) {
      if (ex.message == "E_DB_NO_OBJECT") {
        return null;
      } else {
        throw ex;
      }
    }
  }
  /**
   * Save accumulated changed fields, if any
   * @param {Object} options
   * @param {String} options.behavior - if "REPLACE", does "REPLACE INTO"
   */


  async commit(options = {}) {
    let sql = "";

    if (Object.keys(this._changes).length === 0) {
      return;
    }

    if (this._raw[this._locateField] !== undefined) {
      sql = "UPDATE ";
    } else if (options.behavior === "REPLACE") {
      sql = "REPLACE INTO ";
    } else {
      sql = "INSERT INTO ";
    }

    sql += `${this._tableName} SET `;
    const fields = [];
    const values = [];
    Object.keys(this._changes).forEach(field => {
      fields.push(field + "=?");
      values.push(this._raw[field]);
    });
    sql += fields.join(",");

    if (this._raw[this._locateField] !== undefined) {
      sql += ` WHERE ${this._locateField}=?`;
      values.push(this._raw[this._locateField]);
    } // Compare our dbh.cid and current transaction dbh


    const trxDbh = this._getDbhClass().masterDbhRO(); //console.log("Comparing dbh:", this._dbh.cid, trxDbh? trxDbh.cid: undefined);


    if (trxDbh) {
      if (this._dbh.cid !== trxDbh.cid) {
        throw new Error(`${this.constructor.name}: Object has to be re-created in transaction`);
      }
    }

    const res = await this._dbh.queryAsync(sql, values);
    this._changes = {}; // During the first insert the ${_locatefield()} field will be empty, and,
    // probably, generated by mysql

    if (this._raw[this._locateField] === undefined) {
      this._raw[this._locateField] = res.insertId;

      if (this[this._locateField] === undefined) {
        this._createAccessMethod(this._locateField);
      }
    }
  }
  /**
   * Initializes class from the database or as an empty record.
   *
   * If 'options' contains a property named as _locatefield() defines, then we
   * try to initialize from the database. Exception is thrown if there's no
   * record found.
   *
   * @param options
   * @protected
   */


  async _init(options) {
    let byKey = null;
    const keyArgs = [];

    this.constructor._keys().sort(commaSort).forEach(k => {
      // console.log("key", k);
      if (byKey != null) {
        return;
      } // Check if all key parts are present


      let fits = true;
      k.split(",").forEach(kpart => {
        if (!(kpart in options)) {
          fits = false;
        }
      });

      if (fits) {
        // Key fits, remember it and its arguments
        byKey = k.split(",");
        byKey.forEach(kpart => {
          keyArgs.push(options[kpart]);
        });
      }
    }); // if "_locateField" is set, then we need to read our data from the database


    if (this._locateField in options) {
      await this._read(options[this._locateField]);
    } else if (byKey) {
      await this._readByKey(byKey, keyArgs);
    } else {
      // else create a new record: read the table info and build access methods
      await this._initEmpty();
    }
  }
  /**
   * Reads values from the database, puts them into _raw and creates a function
   * to get each value, so we can access fields as:
   * obj.field();
   * obj.field("new value");
   * @protected
   * @param {*} locateValue - the database unique id of the record
   * @param {String} byKey - the field to search on. $_locateField by default.
   */


  async _read(locateValue, byKey) {
    let field = byKey || this._locateField;
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1 ${forUpdate}`, [locateValue]);
    return this._createFromRows(rows);
  }
  /**
   * Does the same work as _read, but accepts the secondary keys and values arrays
   * @param keys {Array}
   * @param values {Array}
   * @private
   */


  async _readByKey(keys, values) {
    const fields = keys.join("=? AND ") + "=?";
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${fields} LIMIT 1 ${forUpdate}`, values);
    return this._createFromRows(rows);
  }
  /**
   * Initialize object and methods			if(args.Length >= 1 && !UUID.TryParse(args[0], out folder)) {
  			return "FAIL: error parsing folder UUID";
  		}
   from rows array
   * @param rows
   * @private
   */


  _createFromRows(rows) {
    if (rows.length == 0) {
      throw new Error("E_DB_NO_OBJECT");
    }

    this._raw = rows[0]; // Create access methods for all fields

    Object.keys(this._raw).forEach(field => {
      this._createAccessMethod(field);
    });
  }
  /**
   * Initializes an empty object
   * @private
   */


  async _initEmpty() {
    const rows = await this._dbh.queryAsync(`DESCRIBE ${this._tableName}`);
    rows.forEach(field => {
      this._createAccessMethod(field.Field);
    });
  }
  /**
   * The template for access methods. Reads or sets the value of the object field.
   * @param field
   * @param value
   * @private
   */


  _accessField(field, value) {
    // To set NULL field: class.field(null)
    if (value !== undefined) {
      this._changes[field] = true;
      this._raw[field] = value;
    }

    return this._raw[field];
  }
  /**
   * Creates a function within this class to get/set the certain field
   * @param field
   * @private
   */


  _createAccessMethod(field) {
    //console.log("creating", field, typeof this[field]);
    const f = (value = undefined) => {
      return this._accessField(field, value);
    }; // If access function already exists, do not overwrite it. Instead, add a function
    // to this._super object


    if (typeof this[field] === "function") {
      this._super[field] = f;
    } else {
      this[field] = f;
    }
  }
  /**
   * Removes the record from the database. No verification or integrity checks
   * are being performed, they are up to caller.
   */


  async deleteRecord() {
    await this._dbh.queryAsync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`, [this[this._locateField]()]);
  }
  /**
   * Returns master database handle currently in-use. To be used in static
   * methods of DbRecord
   *
   * @returns {MysqlDatabase2} current mysql database connection class
   */


  static masterDbh() {
    return this._getDbhClassStatic().masterDbh();
  }
  /**
   * Runs through database objects according the options, and calls the
   * callback routine for each.
   *
   * @param {Object} options
   * @param {String} options.any_lowercase_field - the field to get added to WHERE
   * @param {[String]} options.whereCond - optional WHERE conditions to add
   * @param {[String]} options.whereParam - optional parameters for whereCond's
   * @param {Boolean} [options.forUpdate] - lock records for update
   * @param {String} [options.ORDERBY] - the sort field or expression
   * @param {String} [options.LIMIT] - the SQL LIMIT expression
   * @param {Boolean} [options.DEBUG_SQL_QUERY] - send SQL to console log
   * @param {Function} cb - the callback function, it receives two arguments:
   * 	the current iteration DbRecord and the "options" object
   *
   * @returns {Number} the number of rows found
   */


  static async forEach(options, cb) {
    const where = [];
    const qparam = [];

    const sql = this._prepareForEach(options, where, qparam); //
    // Iterate


    const _dbh = await this._getDbhClassStatic().masterDbh();

    console.log(`${_dbh._db.threadId}: will be running forEach query`);
    const rows = await _dbh.queryAsync(sql, qparam);
    options.TOTAL = rows.length;

    if (cb) {
      options.COUNTER = 0;

      for (const row of rows) {
        options.COUNTER++;
        const o = {};
        o[this._locatefield()] = row[this._locatefield()];
        const obj = new this(o);
        await obj.init(); // Wait for iterator to end

        await cb(obj, options);
      }
    } else {
      options.COUNTER = options.TOTAL;
    }

    return options.COUNTER;
  }
  /**
   * Prepares SQL and param arrays for forEach()
   * @param options
   * @param where
   * @param qparam
   * @returns {string}
   * @private
   */


  static _prepareForEach(options, where, qparam) {
    let sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;

    if (options.forUpdate) {
      sql += " FOR UPDATE";
    } // WHERE fields


    Object.keys(options).forEach(k => {
      if (k.match(/[^a-z0-9._]/)) {
        return;
      }

      where.push(`${k}=?`);
      qparam.push(options[k]);
    });

    if (options.whereCond) {
      options.whereCond.forEach(q => {
        where.push(`(${q})`);
      });
    }

    if (options.whereParam) {
      options.whereParam.forEach(q => {
        qparam.push(q);
      });
    }

    if (where.length > 0) {
      sql += " WHERE " + where.join(" AND ");
    } // ORDER BY


    if (options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {
      sql += " ORDER BY " + options.ORDERBY;
    } // LIMIT


    if (options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {
      sql += " LIMIT " + options.LIMIT;
    }

    if (options.DEBUG_SQL_QUERY) {
      console.log(sql, qparam);
    }

    return sql;
  }
  /**
   * Starts a transaction and creates an instance of our object within that
   * transaction, passing it to the callback
   * @param {Function} cb - function to run with a "me" newly created objec
   * @returns {Promise<void>}
   */


  async transactionWithMe(cb) {
    const Class = this.constructor; // Make sure we are committed

    if (Object.keys(this._changes).length > 0) {
      throw new Error(`${Class.name}: Object has uncommitted changes before transaction`);
    }

    const dbh = await Class.masterDbh();
    await dbh.execTransactionAsync(async () => {
      const params = {};
      params[this._locateField] = this[this._locateField]();
      const me = new this.constructor(params);
      await me.init();
      return await cb(me);
    }); // Re-read our object after the transaction

    await this._read(this[this._locateField]());
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord class
   * @private
   */


  static _getDbhClassStatic() {
    return _MysqlDatabase.default;
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord object
   * @private
   */


  _getDbhClass() {
    return _MysqlDatabase.default;
  }

}
/**
 * The sorting function to get entries with more commas first
 * @param a
 * @param b
 */


exports.default = DbRecord2;

function commaSort(a, b) {
  const ca = strcount(a, ",");
  const cb = strcount(b, ",");
  return ca > cb ? -1 : 1;
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EYlJlY29yZDIuanMiXSwibmFtZXMiOlsic3RyY291bnQiLCJyZXF1aXJlIiwiRGJSZWNvcmQyIiwiX3RhYmxlIiwiX2xvY2F0ZWZpZWxkIiwiX2tleXMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfcmF3IiwiX2NoYW5nZXMiLCJfc3VwZXIiLCJfdGFibGVOYW1lIiwiX2xvY2F0ZUZpZWxkIiwiX29wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbml0IiwiZGJoIiwiX2RiaCIsIl9nZXREYmhDbGFzcyIsIm1hc3RlckRiaCIsIl9pbml0IiwidHJ5Q3JlYXRlIiwib2JqIiwiZXgiLCJtZXNzYWdlIiwiY29tbWl0Iiwic3FsIiwia2V5cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImJlaGF2aW9yIiwiZmllbGRzIiwidmFsdWVzIiwiZm9yRWFjaCIsImZpZWxkIiwicHVzaCIsImpvaW4iLCJ0cnhEYmgiLCJtYXN0ZXJEYmhSTyIsImNpZCIsIkVycm9yIiwibmFtZSIsInJlcyIsInF1ZXJ5QXN5bmMiLCJpbnNlcnRJZCIsIl9jcmVhdGVBY2Nlc3NNZXRob2QiLCJieUtleSIsImtleUFyZ3MiLCJzb3J0IiwiY29tbWFTb3J0IiwiayIsImZpdHMiLCJzcGxpdCIsImtwYXJ0IiwiX3JlYWQiLCJfcmVhZEJ5S2V5IiwiX2luaXRFbXB0eSIsImxvY2F0ZVZhbHVlIiwiZm9yVXBkYXRlIiwicm93cyIsIl9jcmVhdGVGcm9tUm93cyIsIkZpZWxkIiwiX2FjY2Vzc0ZpZWxkIiwidmFsdWUiLCJmIiwiZGVsZXRlUmVjb3JkIiwiX2dldERiaENsYXNzU3RhdGljIiwiY2IiLCJ3aGVyZSIsInFwYXJhbSIsIl9wcmVwYXJlRm9yRWFjaCIsImNvbnNvbGUiLCJsb2ciLCJfZGIiLCJ0aHJlYWRJZCIsIlRPVEFMIiwiQ09VTlRFUiIsInJvdyIsIm8iLCJtYXRjaCIsIndoZXJlQ29uZCIsInEiLCJ3aGVyZVBhcmFtIiwiT1JERVJCWSIsIkxJTUlUIiwidG9TdHJpbmciLCJERUJVR19TUUxfUVVFUlkiLCJ0cmFuc2FjdGlvbldpdGhNZSIsIkNsYXNzIiwiZXhlY1RyYW5zYWN0aW9uQXN5bmMiLCJwYXJhbXMiLCJtZSIsIk15c3FsRGF0YWJhc2UyIiwiYSIsImIiLCJjYSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7O0FBQ0EsTUFBTUEsUUFBUSxHQUFHQyxPQUFPLENBQUMsMEJBQUQsQ0FBeEI7QUFFQTs7Ozs7QUFHZSxNQUFNQyxTQUFOLENBQWdCO0FBQzlCLFNBQU9DLE1BQVAsR0FBZ0I7QUFBRSxVQUFNLG9DQUFOO0FBQTZDOztBQUMvRCxTQUFPQyxZQUFQLEdBQXNCO0FBQUUsVUFBTSxvQ0FBTjtBQUE2Qzs7QUFDckUsU0FBT0MsS0FBUCxHQUFlO0FBQUUsV0FBTyxFQUFQO0FBQVk7QUFFN0I7Ozs7Ozs7Ozs7QUFRQUMsRUFBQUEsV0FBVyxDQUFDQyxPQUFPLEdBQUcsRUFBWCxFQUFlO0FBQ3pCOzs7QUFHQSxTQUFLQyxJQUFMLEdBQVksRUFBWjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0IsRUFBaEI7QUFDQSxTQUFLQyxNQUFMLEdBQWMsRUFBZCxDQU55QixDQU1QOztBQUVsQixTQUFLQyxVQUFMLEdBQWtCLEtBQUtMLFdBQUwsQ0FBaUJILE1BQWpCLEVBQWxCO0FBQ0EsU0FBS1MsWUFBTCxHQUFvQixLQUFLTixXQUFMLENBQWlCRixZQUFqQixFQUFwQjtBQUVBLFNBQUtTLFFBQUwsR0FBZ0JDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JSLE9BQWxCLENBQWhCO0FBQ0E7QUFFRDs7Ozs7O0FBSUEsUUFBTVMsSUFBTixHQUFhO0FBQ1o7QUFDQSxRQUFHLEtBQUtILFFBQUwsQ0FBY0ksR0FBakIsRUFBc0I7QUFDckIsV0FBS0MsSUFBTCxHQUFZLEtBQUtMLFFBQUwsQ0FBY0ksR0FBMUI7QUFDQSxLQUZELE1BRU87QUFDTixXQUFLQyxJQUFMLEdBQVksTUFBTSxLQUFLQyxZQUFMLEdBQW9CQyxTQUFwQixFQUFsQjtBQUNBLEtBTlcsQ0FRWjs7O0FB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LFFBQVEsQ0FBQzhGLENBQUQsRUFBSSxHQUFKLENBQW5CO0FBQ0EsUUFBTTFCLEVBQUUsR0FBR3BFLFFBQVEsQ0FBQytGLENBQUQsRUFBSSxHQUFKLENBQW5CO0FBQ0EsU0FBT0MsRUFBRSxHQUFDNUIsRUFBSCxHQUFPLENBQUMsQ0FBUixHQUFZLENBQW5CO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTXlzcWxEYXRhYmFzZTIgZnJvbSBcIi4vTXlzcWxEYXRhYmFzZTJcIjtcbmNvbnN0IHN0cmNvdW50ID0gcmVxdWlyZSgncXVpY2tseS1jb3VudC1zdWJzdHJpbmdzJyk7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGF0YWJhc2UgcmVjb3JkIGNsYXNzLlxuKiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEYlJlY29yZDIge1xuXHRzdGF0aWMgX3RhYmxlKCkgeyB0aHJvdyBcIkRiUmVjb3JkIGNhbid0IGJlIGNyZWF0ZWQgZGlyZWN0bHlcIjsgfVxuXHRzdGF0aWMgX2xvY2F0ZWZpZWxkKCkgeyB0aHJvdyBcIkRiUmVjb3JkIGNhbid0IGJlIGNyZWF0ZWQgZGlyZWN0bHlcIjsgfVxuXHRzdGF0aWMgX2tleXMoKSB7IHJldHVybiBbXTsgfVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIHRoZSBjbGFzcyBpbnN0YW5jZS4gSWYgb3B0aW9ucy4ke19sb2NhdGVmaWVsZCgpfSBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkLFxuXHQgKiByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBkYXRhYmFzZSBhbmQgcHV0IHRoZW0gaW50byB0aGUgaW50ZXJuYWwgc3RydWN0dXJlc1xuXHQgKiAoc2VlIF9pbml0KCkgYW5kIF9yZWFkKCkpXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb3JVcGRhdGVdIC0gcmVhZCByZWNvcmQgd2l0aCBGT1IgVVBEQVRFIGZsYWcsXG5cdCAqIFx0YmxvY2tpbmcgaXQgd2l0aGluIHRoZSB0cmFuc2FjdGlvblxuXHQgKi9cblx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG5cdFx0LyoqXG5cdFx0ICogVGhlIGRhdGFiYXNlIGhhbmRsZXIgdG8gd29yayB3aXRoXG5cdFx0ICovXG5cdFx0dGhpcy5fcmF3ID0ge307XG5cdFx0dGhpcy5fY2hhbmdlcyA9IHt9O1xuXHRcdHRoaXMuX3N1cGVyID0ge307IC8vIFRvIGhvbGQgdGhlIGV4aXN0aW5nIGFjY2VzcyBtZXRob2QgZnVuY3Rpb25zXG5cblx0XHR0aGlzLl90YWJsZU5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLl90YWJsZSgpO1xuXHRcdHRoaXMuX2xvY2F0ZUZpZWxkID0gdGhpcy5jb25zdHJ1Y3Rvci5fbG9jYXRlZmllbGQoKTtcblxuXHRcdHRoaXMuX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGNsYXNzIHN0cnVjdHVyZXMsIHJlYWQgZGF0YWJhc2Vcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyBpbml0KCkge1xuXHRcdC8vIFVzZSBlaXRoZXIgbG9jYWxseSBwcm92aWRlZCBvciBkYXRhYmFzZSBoYW5kbGVyIGZhY3Rvcnlcblx0XHRpZih0aGlzLl9vcHRpb25zLmRiaCkge1xuXHRcdFx0dGhpcy5fZGJoID0gdGhpcy5fb3B0aW9ucy5kYmg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2RiaCA9IGF3YWl0IHRoaXMuX2dldERiaENsYXNzKCkubWFzdGVyRGJoKCk7XG5cdFx0fVxuXG5cdFx0Ly9jb25zb2xlLmxvZyhcInVzaW5nIHRyeERiaDpcIiwgdGhpcy5fZGJoLmNpZCk7XG5cblx0XHRhd2FpdCB0aGlzLl9pbml0KHRoaXMuX29wdGlvbnMpO1xuXHR9XG5cblxuXHQvKipcblx0ICogVHJpZXMgY3JlYXRpbmcgYW4gb2JqZWN0IGJ5IGxvY2F0ZSBmaWVsZC9rZXlzLiBVbmxpa2UgY29uc3RydWN0b3IsIGRvZXNcblx0ICogbm90IHRocm93IGFuIGVycm9yIGZvciBub24tZXhpc3RpbmcgcmVjb3JkIGFuZCByZXR1cm5zIG51bGwgaW5zdGVhZC5cblx0ICogQHBhcmFtIG9wdGlvbnNcblx0ICovXG5cdHN0YXRpYyBhc3luYyB0cnlDcmVhdGUob3B0aW9ucyA9IHt9KSB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IG9iaiA9IG5ldyB0aGlzKG9wdGlvbnMpO1xuXHRcdFx0YXdhaXQgb2JqLmluaXQoKTtcblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSBjYXRjaChleCkge1xuXHRcdFx0aWYoZXgubWVzc2FnZSA9PSBcIkVfREJfTk9fT0JKRUNUXCIpIHsgcmV0dXJuIG51bGw7IH1cblx0XHRcdGVsc2UgeyB0aHJvdyBleDsgfVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlIGFjY3VtdWxhdGVkIGNoYW5nZWQgZmllbGRzLCBpZiBhbnlcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYmVoYXZpb3IgLSBpZiBcIlJFUExBQ0VcIiwgZG9lcyBcIlJFUExBQ0UgSU5UT1wiXG5cdCAqL1xuXHRhc3luYyBjb21taXQob3B0aW9ucyA9IHt9KSB7XG5cdFx0bGV0IHNxbCA9IFwiXCI7XG5cblx0XHRpZihPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VzKS5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZih0aGlzLl9yYXdbdGhpcy5fbG9jYXRlRmllbGRdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHNxbCA9IFwiVVBEQVRFIFwiO1xuXHRcdH0gZWxzZSBpZihvcHRpb25zLmJlaGF2aW9yID09PSBcIlJFUExBQ0VcIikge1xuXHRcdFx0c3FsID0gXCJSRVBMQUNFIElOVE8gXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNxbCA9IFwiSU5TRVJUIElOVE8gXCI7XG5cdFx0fVxuXG5cdFx0c3FsICs9IGAke3RoaXMuX3RhYmxlTmFtZX0gU0VUIGA7XG5cdFx0Y29uc3QgZmllbGRzID0gW107XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0T2JqZWN0LmtleXModGhpcy5fY2hhbmdlcykuZm9yRWFjaCgoZmllbGQpID0+IHtcblx0XHRcdGZpZWxkcy5wdXNoKGZpZWxkICsgXCI9P1wiKTtcblx0XHRcdHZhbHVlcy5wdXNoKHRoaXMuX3Jhd1tmaWVsZF0pO1xuXHRcdH0pO1xuXG5cdFx0c3FsICs9IGZpZWxkcy5qb2luKFwiLFwiKTtcblxuXHRcdGlmKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3FsICs9IGAgV0hFUkUgJHt0aGlzLl9sb2NhdGVGaWVsZH09P2A7XG5cdFx0XHR2YWx1ZXMucHVzaCh0aGlzLl9yYXdbdGhpcy5fbG9jYXRlRmllbGRdKTtcblx0XHR9XG5cblx0XHQvLyBDb21wYXJlIG91ciBkYmguY2lkIGFuZCBjdXJyZW50IHRyYW5zYWN0aW9uIGRiaFxuXHRcdGNvbnN0IHRyeERiaCA9IHRoaXMuX2dldERiaENsYXNzKCkubWFzdGVyRGJoUk8oKTtcblxuXHRcdC8vY29uc29sZS5sb2coXCJDb21wYXJpbmcgZGJoOlwiLCB0aGlzLl9kYmguY2lkLCB0cnhEYmg/IHRyeERiaC5jaWQ6IHVuZGVmaW5lZCk7XG5cblx0XHRpZih0cnhEYmgpIHtcblx0XHRcdGlmKHRoaXMuX2RiaC5jaWQgIT09IHRyeERiaC5jaWQpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX06IE9iamVjdCBoYXMgdG8gYmUgcmUtY3JlYXRlZCBpbiB0cmFuc2FjdGlvbmApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKFRBUkdFVCA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhgJHt0aGlzLl9kYmguX2RiLnRocmVhZElkfTogaW4gY29tbWl0IGJlZm9yZSBxdWVyeWApO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2RiaC5xdWVyeUFzeW5jKHNxbCwgdmFsdWVzKTtcblxuXHRcdHRoaXMuX2NoYW5nZXMgPSB7fTtcblxuXHRcdC8vIER1cmluZyB0aGUgZmlyc3QgaW5zZXJ0IHRoZSAke19sb2NhdGVmaWVsZCgpfSBmaWVsZCB3aWxsIGJlIGVtcHR5LCBhbmQsXG5cdFx0Ly8gcHJvYmFibHksIGdlbmVyYXRlZCBieSBteXNxbFxuXHRcdGlmKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fcmF3W3RoaXMuX2xvY2F0ZUZpZWxkXSA9IHJlcy5pbnNlcnRJZDtcblxuXHRcdFx0aWYodGhpc1t0aGlzLl9sb2NhdGVGaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHR0aGlzLl9jcmVhdGVBY2Nlc3NNZXRob2QodGhpcy5fbG9jYXRlRmllbGQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyBjbGFzcyBmcm9tIHRoZSBkYXRhYmFzZSBvciBhcyBhbiBlbXB0eSByZWNvcmQuXG5cdCAqXG5cdCAqIElmICdvcHRpb25zJyBjb250YWlucyBhIHByb3BlcnR5IG5hbWVkIGFzIF9sb2NhdGVmaWVsZCgpIGRlZmluZXMsIHRoZW4gd2Vcblx0ICogdHJ5IHRvIGluaXRpYWxpemUgZnJvbSB0aGUgZGF0YWJhc2UuIEV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgdGhlcmUncyBub1xuXHQgKiByZWNvcmQgZm91bmQuXG5cdCAqXG5cdCAqIEBwYXJhbSBvcHRpb25zXG5cdCAqIEBwcm90ZWN0ZWRcblx0ICovXG5cdGFzeW5jIF9pbml0KG9wdGlvbnMpIHtcblx0XHRsZXQgYnlLZXkgPSBudWxsO1xuXHRcdGNvbnN0IGtleUFyZ3MgPSBbXTtcblxuXHRcdHRoaXMuY29uc3RydWN0b3IuX2tleXMoKS5zb3J0KGNvbW1hU29ydCkuZm9yRWFjaCgoaykgPT4ge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coXCJrZXlcIiwgayk7XG5cdFx0XHRpZihieUtleSAhPSBudWxsKSB7IHJldHVybjsgfVxuXG5cdFx0XHQvLyBDaGVjayBpZiBhbGwga2V5IHBhcnRzIGFyZSBwcmVzZW50XG5cdFx0XHRsZXQgZml0cyA9IHRydWU7XG5cdFx0XHRrLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChrcGFydCkgPT4ge1xuXHRcdFx0XHRpZighKGtwYXJ0IGluIG9wdGlvbnMpKSB7IGZpdHMgPSBmYWxzZTsgfVxuXHRcdFx0fSk7XG5cblx0XHRcdGlmKGZpdHMpIHtcblx0XHRcdFx0Ly8gS2V5IGZpdHMsIHJlbWVtYmVyIGl0IGFuZCBpdHMgYXJndW1lbnRzXG5cdFx0XHRcdGJ5S2V5ID0gay5zcGxpdChcIixcIik7XG5cdFx0XHRcdGJ5S2V5LmZvckVhY2goKGtwYXJ0KSA9PiB7XG5cdFx0XHRcdFx0a2V5QXJncy5wdXNoKG9wdGlvbnNba3BhcnRdKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBpZiBcIl9sb2NhdGVGaWVsZFwiIGlzIHNldCwgdGhlbiB3ZSBuZWVkIHRvIHJlYWQgb3VyIGRhdGEgZnJvbSB0aGUgZGF0YWJhc2Vcblx0XHRpZih0aGlzLl9sb2NhdGVGaWVsZCBpbiBvcHRpb25zKSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9yZWFkKG9wdGlvbnNbdGhpcy5fbG9jYXRlRmllbGRdKTtcblx0XHR9XG5cdFx0ZWxzZSBpZihieUtleSkge1xuXHRcdFx0YXdhaXQgdGhpcy5fcmVhZEJ5S2V5KGJ5S2V5LCBrZXlBcmdzKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBlbHNlIGNyZWF0ZSBhIG5ldyByZWNvcmQ6IHJlYWQgdGhlIHRhYmxlIGluZm8gYW5kIGJ1aWxkIGFjY2VzcyBtZXRob2RzXG5cdFx0XHRhd2FpdCB0aGlzLl9pbml0RW1wdHkoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVhZHMgdmFsdWVzIGZyb20gdGhlIGRhdGFiYXNlLCBwdXRzIHRoZW0gaW50byBfcmF3IGFuZCBjcmVhdGVzIGEgZnVuY3Rpb25cblx0ICogdG8gZ2V0IGVhY2ggdmFsdWUsIHNvIHdlIGNhbiBhY2Nlc3MgZmllbGRzIGFzOlxuXHQgKiBvYmouZmllbGQoKTtcblx0ICogb2JqLmZpZWxkKFwibmV3IHZhbHVlXCIpO1xuXHQgKiBAcHJvdGVjdGVkXG5cdCAqIEBwYXJhbSB7Kn0gbG9jYXRlVmFsdWUgLSB0aGUgZGF0YWJhc2UgdW5pcXVlIGlkIG9mIHRoZSByZWNvcmRcblx0ICogQHBhcmFtIHtTdHJpbmd9IGJ5S2V5IC0gdGhlIGZpZWxkIHRvIHNlYXJjaCBvbi4gJF9sb2NhdGVGaWVsZCBieSBkZWZhdWx0LlxuXHQgKi9cblx0YXN5bmMgX3JlYWQobG9jYXRlVmFsdWUsIGJ5S2V5KSB7XG5cdFx0bGV0IGZpZWxkID0gYnlLZXkgfHwgdGhpcy5fbG9jYXRlRmllbGQ7XG5cdFx0Y29uc3QgZm9yVXBkYXRlID0gdGhpcy5fb3B0aW9ucy5mb3JVcGRhdGU/IFwiRk9SIFVQREFURVwiOiBcIlwiO1xuXG5cdFx0Y29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuX2RiaC5xdWVyeUFzeW5jKGBTRUxFQ1QgKiBGUk9NICR7dGhpcy5fdGFibGVOYW1lfSBXSEVSRSAke2ZpZWxkfT0/IExJTUlUIDEgJHtmb3JVcGRhdGV9YCxcblx0XHRcdFtsb2NhdGVWYWx1ZV0pO1xuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUm93cyhyb3dzKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIERvZXMgdGhlIHNhbWUgd29yayBhcyBfcmVhZCwgYnV0IGFjY2VwdHMgdGhlIHNlY29uZGFyeSBrZXlzIGFuZCB2YWx1ZXMgYXJyYXlzXG5cdCAqIEBwYXJhbSBrZXlzIHtBcnJheX1cblx0ICogQHBhcmFtIHZhbHVlcyB7QXJyYXl9XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhc3luYyBfcmVhZEJ5S2V5KGtleXMsIHZhbHVlcykge1xuXHRcdGNvbnN0IGZpZWxkcyA9IGtleXMuam9pbihcIj0/IEFORCBcIikgKyBcIj0/XCI7XG5cdFx0Y29uc3QgZm9yVXBkYXRlID0gdGhpcy5fb3B0aW9ucy5mb3JVcGRhdGU/IFwiRk9SIFVQREFURVwiOiBcIlwiO1xuXG5cdFx0Y29uc3Qgcm93cyA9IGF3YWl0IHRoaXMuX2RiaC5xdWVyeUFzeW5jKGBTRUxFQ1QgKiBGUk9NICR7dGhpcy5fdGFibGVOYW1lfSBXSEVSRSAke2ZpZWxkc30gTElNSVQgMSAke2ZvclVwZGF0ZX1gLFxuXHRcdFx0dmFsdWVzKTtcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlRnJvbVJvd3Mocm93cyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIG9iamVjdCBhbmQgbWV0aG9kc1x0XHRcdGlmKGFyZ3MuTGVuZ3RoID49IDEgJiYgIVVVSUQuVHJ5UGFyc2UoYXJnc1swXSwgb3V0IGZvbGRlcikpIHtcblx0XHRcdFx0cmV0dXJuIFwiRkFJTDogZXJyb3IgcGFyc2luZyBmb2xkZXIgVVVJRFwiO1xuXHRcdFx0fVxuXHQgZnJvbSByb3dzIGFycmF5XG5cdCAqIEBwYXJhbSByb3dzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY3JlYXRlRnJvbVJvd3Mocm93cykge1xuXHRcdGlmKHJvd3MubGVuZ3RoID09IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkVfREJfTk9fT0JKRUNUXCIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3JhdyA9IHJvd3NbMF07XG5cblx0XHQvLyBDcmVhdGUgYWNjZXNzIG1ldGhvZHMgZm9yIGFsbCBmaWVsZHNcblx0XHRPYmplY3Qua2V5cyh0aGlzLl9yYXcpLmZvckVhY2goKGZpZWxkKSA9PiB7IHRoaXMuX2NyZWF0ZUFjY2Vzc01ldGhvZChmaWVsZCk7IH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGFuIGVtcHR5IG9iamVjdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0YXN5bmMgX2luaXRFbXB0eSgpIHtcblx0XHRjb25zdCByb3dzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYERFU0NSSUJFICR7dGhpcy5fdGFibGVOYW1lfWApO1xuXHRcdHJvd3MuZm9yRWFjaCgoZmllbGQpID0+IHsgdGhpcy5fY3JlYXRlQWNjZXNzTWV0aG9kKGZpZWxkLkZpZWxkKTsgfSk7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIHRlbXBsYXRlIGZvciBhY2Nlc3MgbWV0aG9kcy4gUmVhZHMgb3Igc2V0cyB0aGUgdmFsdWUgb2YgdGhlIG9iamVjdCBmaWVsZC5cblx0ICogQHBhcmFtIGZpZWxkXG5cdCAqIEBwYXJhbSB2YWx1ZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2FjY2Vzc0ZpZWxkKGZpZWxkLCB2YWx1ZSkge1xuXHRcdC8vIFRvIHNldCBOVUxMIGZpZWxkOiBjbGFzcy5maWVsZChudWxsKVxuXHRcdGlmKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX2NoYW5nZXNbZmllbGRdID0gdHJ1ZTtcblx0XHRcdHRoaXMuX3Jhd1tmaWVsZF0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fcmF3W2ZpZWxkXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2l0aGluIHRoaXMgY2xhc3MgdG8gZ2V0L3NldCB0aGUgY2VydGFpbiBmaWVsZFxuXHQgKiBAcGFyYW0gZmllbGRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGVBY2Nlc3NNZXRob2QoZmllbGQpIHtcblx0XHQvL2NvbnNvbGUubG9nKFwiY3JlYXRpbmdcIiwgZmllbGQsIHR5cGVvZiB0aGlzW2ZpZWxkXSk7XG5cdFx0Y29uc3QgZiA9ICh2YWx1ZSA9IHVuZGVmaW5lZCkgPT4geyByZXR1cm4gdGhpcy5fYWNjZXNzRmllbGQoZmllbGQsIHZhbHVlKTsgfTtcblxuXHRcdC8vIElmIGFjY2VzcyBmdW5jdGlvbiBhbHJlYWR5IGV4aXN0cywgZG8gbm90IG92ZXJ3cml0ZSBpdC4gSW5zdGVhZCwgYWRkIGEgZnVuY3Rpb25cblx0XHQvLyB0byB0aGlzLl9zdXBlciBvYmplY3Rcblx0XHRpZih0eXBlb2YgdGhpc1tmaWVsZF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0dGhpcy5fc3VwZXJbZmllbGRdID0gZjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1tmaWVsZF0gPSBmO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgdGhlIHJlY29yZCBmcm9tIHRoZSBkYXRhYmFzZS4gTm8gdmVyaWZpY2F0aW9uIG9yIGludGVncml0eSBjaGVja3Ncblx0ICogYXJlIGJlaW5nIHBlcmZvcm1lZCwgdGhleSBhcmUgdXAgdG8gY2FsbGVyLlxuXHQgKi9cblx0YXN5bmMgZGVsZXRlUmVjb3JkKCkge1xuXHRcdGF3YWl0IHRoaXMuX2RiaC5xdWVyeUFzeW5jKGBERUxFVEUgRlJPTSAke3RoaXMuX3RhYmxlTmFtZX0gV0hFUkUgJHt0aGlzLl9sb2NhdGVGaWVsZH0gPSA/YCxcblx0XHRcdFsgdGhpc1t0aGlzLl9sb2NhdGVGaWVsZF0oKSBdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIG1hc3RlciBkYXRhYmFzZSBoYW5kbGUgY3VycmVudGx5IGluLXVzZS4gVG8gYmUgdXNlZCBpbiBzdGF0aWNcblx0ICogbWV0aG9kcyBvZiBEYlJlY29yZFxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TXlzcWxEYXRhYmFzZTJ9IGN1cnJlbnQgbXlzcWwgZGF0YWJhc2UgY29ubmVjdGlvbiBjbGFzc1xuXHQgKi9cblx0c3RhdGljIG1hc3RlckRiaCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0RGJoQ2xhc3NTdGF0aWMoKS5tYXN0ZXJEYmgoKTtcblx0fVxuXG5cblxuXHQvKipcblx0ICogUnVucyB0aHJvdWdoIGRhdGFiYXNlIG9iamVjdHMgYWNjb3JkaW5nIHRoZSBvcHRpb25zLCBhbmQgY2FsbHMgdGhlXG5cdCAqIGNhbGxiYWNrIHJvdXRpbmUgZm9yIGVhY2guXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmFueV9sb3dlcmNhc2VfZmllbGQgLSB0aGUgZmllbGQgdG8gZ2V0IGFkZGVkIHRvIFdIRVJFXG5cdCAqIEBwYXJhbSB7W1N0cmluZ119IG9wdGlvbnMud2hlcmVDb25kIC0gb3B0aW9uYWwgV0hFUkUgY29uZGl0aW9ucyB0byBhZGRcblx0ICogQHBhcmFtIHtbU3RyaW5nXX0gb3B0aW9ucy53aGVyZVBhcmFtIC0gb3B0aW9uYWwgcGFyYW1ldGVycyBmb3Igd2hlcmVDb25kJ3Ncblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb3JVcGRhdGVdIC0gbG9jayByZWNvcmRzIGZvciB1cGRhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLk9SREVSQlldIC0gdGhlIHNvcnQgZmllbGQgb3IgZXhwcmVzc2lvblxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuTElNSVRdIC0gdGhlIFNRTCBMSU1JVCBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuREVCVUdfU1FMX1FVRVJZXSAtIHNlbmQgU1FMIHRvIGNvbnNvbGUgbG9nXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpdCByZWNlaXZlcyB0d28gYXJndW1lbnRzOlxuXHQgKiBcdHRoZSBjdXJyZW50IGl0ZXJhdGlvbiBEYlJlY29yZCBhbmQgdGhlIFwib3B0aW9uc1wiIG9iamVjdFxuXHQgKlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB0aGUgbnVtYmVyIG9mIHJvd3MgZm91bmRcblx0ICovXG5cdHN0YXRpYyBhc3luYyBmb3JFYWNoKG9wdGlvbnMsIGNiKSB7XG5cdFx0Y29uc3Qgd2hlcmUgPSBbXTtcblx0XHRjb25zdCBxcGFyYW0gPSBbXTtcblx0XHRjb25zdCBzcWwgPSB0aGlzLl9wcmVwYXJlRm9yRWFjaChvcHRpb25zLCB3aGVyZSwgcXBhcmFtKTtcblxuXHRcdC8vXG5cdFx0Ly8gSXRlcmF0ZVxuXHRcdGNvbnN0IF9kYmggPSBhd2FpdCB0aGlzLl9nZXREYmhDbGFzc1N0YXRpYygpLm1hc3RlckRiaCgpO1xuXG5cdFx0aWYoVEFSR0VUID09PSBcImRldmVsb3BtZW50XCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKGAke19kYmguX2RiLnRocmVhZElkfTogd2lsbCBiZSBydW5uaW5nIGZvckVhY2ggcXVlcnlgKTtcblx0XHR9XG5cblx0XHRjb25zdCByb3dzID0gYXdhaXQgX2RiaC5xdWVyeUFzeW5jKHNxbCwgcXBhcmFtKTtcblx0XHRvcHRpb25zLlRPVEFMID0gcm93cy5sZW5ndGg7XG5cblx0XHRpZihjYikge1xuXHRcdFx0b3B0aW9ucy5DT1VOVEVSID0gMDtcblxuXHRcdFx0Zm9yKGNvbnN0IHJvdyBvZiByb3dzKSB7XG5cdFx0XHRcdG9wdGlvbnMuQ09VTlRFUisrO1xuXG5cdFx0XHRcdGNvbnN0IG8gPSB7fTtcblx0XHRcdFx0b1t0aGlzLl9sb2NhdGVmaWVsZCgpXSA9IHJvd1t0aGlzLl9sb2NhdGVmaWVsZCgpXTtcblx0XHRcdFx0Y29uc3Qgb2JqID0gbmV3IHRoaXMobyk7XG5cdFx0XHRcdGF3YWl0IG9iai5pbml0KCk7XG5cblx0XHRcdFx0Ly8gV2FpdCBmb3IgaXRlcmF0b3IgdG8gZW5kXG5cdFx0XHRcdGF3YWl0IGNiKG9iaiwgb3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9wdGlvbnMuQ09VTlRFUiA9IG9wdGlvbnMuVE9UQUw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG9wdGlvbnMuQ09VTlRFUjtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFByZXBhcmVzIFNRTCBhbmQgcGFyYW0gYXJyYXlzIGZvciBmb3JFYWNoKClcblx0ICogQHBhcmFtIG9wdGlvbnNcblx0ICogQHBhcmFtIHdoZXJlXG5cdCAqIEBwYXJhbSBxcGFyYW1cblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICogQHByaXZhdGVcblx0ICovXG5cdHN0YXRpYyBfcHJlcGFyZUZvckVhY2gob3B0aW9ucywgd2hlcmUsIHFwYXJhbSkge1xuXHRcdGxldCBzcWwgPSBgU0VMRUNUICR7dGhpcy5fbG9jYXRlZmllbGQoKX0gRlJPTSAke3RoaXMuX3RhYmxlKCl9YDtcblx0XHRpZihvcHRpb25zLmZvclVwZGF0ZSkgeyBzcWwgKz0gXCIgRk9SIFVQREFURVwiOyB9XG5cblxuXHRcdC8vIFdIRVJFIGZpZWxkc1xuXHRcdE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2goKGspID0+IHtcblx0XHRcdGlmKGsubWF0Y2goL1teYS16MC05Ll9dLykpIHsgcmV0dXJuOyB9XG5cblx0XHRcdHdoZXJlLnB1c2goYCR7a309P2ApO1xuXHRcdFx0cXBhcmFtLnB1c2gob3B0aW9uc1trXSk7XG5cdFx0fSk7XG5cblx0XHRpZihvcHRpb25zLndoZXJlQ29uZCkge1xuXHRcdFx0b3B0aW9ucy53aGVyZUNvbmQuZm9yRWFjaCgocSkgPT4ge1xuXHRcdFx0XHR3aGVyZS5wdXNoKGAoJHtxfSlgKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMud2hlcmVQYXJhbSkge1xuXHRcdFx0b3B0aW9ucy53aGVyZVBhcmFtLmZvckVhY2goKHEpID0+IHtcblx0XHRcdFx0cXBhcmFtLnB1c2gocSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZih3aGVyZS5sZW5ndGggPiAwKSB7XG5cdFx0XHRzcWwgKz0gXCIgV0hFUkUgXCIgKyB3aGVyZS5qb2luKFwiIEFORCBcIik7XG5cdFx0fVxuXG5cblx0XHQvLyBPUkRFUiBCWVxuXHRcdGlmKG9wdGlvbnMuT1JERVJCWSAmJiAhb3B0aW9ucy5PUkRFUkJZLm1hdGNoKC9bXmEtekEtWjAtOSA+PC1dLykpIHtcblx0XHRcdHNxbCArPSBcIiBPUkRFUiBCWSBcIiArIG9wdGlvbnMuT1JERVJCWTtcblx0XHR9XG5cblx0XHQvLyBMSU1JVFxuXHRcdGlmKG9wdGlvbnMuTElNSVQgJiYgIW9wdGlvbnMuTElNSVQudG9TdHJpbmcoKS5tYXRjaCgvW14wLTksIF0vKSkge1xuXHRcdFx0c3FsICs9IFwiIExJTUlUIFwiICsgb3B0aW9ucy5MSU1JVDtcblx0XHR9XG5cblx0XHRpZihvcHRpb25zLkRFQlVHX1NRTF9RVUVSWSkge1xuXHRcdFx0Y29uc29sZS5sb2coc3FsLCBxcGFyYW0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzcWw7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBTdGFydHMgYSB0cmFuc2FjdGlvbiBhbmQgY3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBvdXIgb2JqZWN0IHdpdGhpbiB0aGF0XG5cdCAqIHRyYW5zYWN0aW9uLCBwYXNzaW5nIGl0IHRvIHRoZSBjYWxsYmFja1xuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGZ1bmN0aW9uIHRvIHJ1biB3aXRoIGEgXCJtZVwiIG5ld2x5IGNyZWF0ZWQgb2JqZWNcblx0ICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG5cdCAqL1xuXHRhc3luYyB0cmFuc2FjdGlvbldpdGhNZShjYikge1xuXHRcdGNvbnN0IENsYXNzID0gdGhpcy5jb25zdHJ1Y3RvcjtcblxuXHRcdC8vIE1ha2Ugc3VyZSB3ZSBhcmUgY29tbWl0dGVkXG5cdFx0aWYoT2JqZWN0LmtleXModGhpcy5fY2hhbmdlcykubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke0NsYXNzLm5hbWV9OiBPYmplY3QgaGFzIHVuY29tbWl0dGVkIGNoYW5nZXMgYmVmb3JlIHRyYW5zYWN0aW9uYCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZGJoID0gYXdhaXQgQ2xhc3MubWFzdGVyRGJoKCk7XG5cdFx0YXdhaXQgZGJoLmV4ZWNUcmFuc2FjdGlvbkFzeW5jKGFzeW5jICgpID0+IHtcblx0XHRcdGNvbnN0IHBhcmFtcyA9IHt9O1xuXHRcdFx0cGFyYW1zW3RoaXMuX2xvY2F0ZUZpZWxkXSA9IHRoaXNbdGhpcy5fbG9jYXRlRmllbGRdKCk7XG5cdFx0XHRjb25zdCBtZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHBhcmFtcyk7XG5cdFx0XHRhd2FpdCBtZS5pbml0KCk7XG5cblx0XHRcdHJldHVybiBhd2FpdCBjYihtZSk7XG5cdFx0fSk7XG5cblx0XHQvLyBSZS1yZWFkIG91ciBvYmplY3QgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uXG5cdFx0YXdhaXQgdGhpcy5fcmVhZCh0aGlzW3RoaXMuX2xvY2F0ZUZpZWxkXSgpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIE15c3FsRGF0YWJhc2UgY2xhc3MgdXNlZCBmb3IgdGhpcyBEYlJlY29yZCBjbGFzc1xuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhdGljIF9nZXREYmhDbGFzc1N0YXRpYygpIHtcblx0XHRyZXR1cm4gTXlzcWxEYXRhYmFzZTI7XG5cdH1cblx0LyoqXG5cdCAqIFJldHVybnMgTXlzcWxEYXRhYmFzZSBjbGFzcyB1c2VkIGZvciB0aGlzIERiUmVjb3JkIG9iamVjdFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2dldERiaENsYXNzKCkge1xuXHRcdHJldHVybiBNeXNxbERhdGFiYXNlMjtcblx0fVxufVxuXG5cbi8qKlxuICogVGhlIHNvcnRpbmcgZnVuY3Rpb24gdG8gZ2V0IGVudHJpZXMgd2l0aCBtb3JlIGNvbW1hcyBmaXJzdFxuICogQHBhcmFtIGFcbiAqIEBwYXJhbSBiXG4gKi9cbmZ1bmN0aW9uIGNvbW1hU29ydChhLGIpIHtcblx0Y29uc3QgY2EgPSBzdHJjb3VudChhLCBcIixcIik7XG5cdGNvbnN0IGNiID0gc3RyY291bnQoYiwgXCIsXCIpO1xuXHRyZXR1cm4gY2E+Y2I/IC0xIDogMTtcbn1cbiJdfQ==