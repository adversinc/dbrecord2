"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MysqlDatabase = _interopRequireDefault(require("./MysqlDatabase2"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const strcount = require('quickly-count-substrings');
/**
 * Represents the database record class.
**/


class DbRecord2 {
  static _table() {
    throw "DbRecord can't be created directly";
  }

  static _locatefield() {
    throw "DbRecord can't be created directly";
  }

  static _keys() {
    return [];
  }
  /**
   * Creates the class instance. If options.${_locatefield()} parameter is specified,
   * reads the data from the database and put them into the internal structures
   * (see _init() and _read())
   * @param {Object} [options]
   * @param {Boolean} [options.forUpdate] - read record with FOR UPDATE flag,
   * 	blocking it within the transaction
   */


  constructor(options = {}) {
    /**
     * The database handler to work with
     */
    this._raw = {};
    this._changes = {};
    this._super = {}; // To hold the existing access method functions

    this._tableName = this.constructor._table();
    this._locateField = this.constructor._locatefield();
    this._options = Object.assign({}, options);
  }
  /**
   * Initialize class structures, read database
   * @returns {Promise<void>}
   */


  async init() {
    // Use either locally provided or database handler factory
    if (this._options.dbh) {
      this._dbh = this._options.dbh;
    } else {
      this._dbh = await this._getDbhClass().masterDbh();
    } //console.log("using trxDbh:", this._dbh.cid);


    await this._init(this._options);
  }
  /**
   * Tries creating an object by locate field/keys. Unlike constructor, does
   * not throw an error for non-existing record and returns null instead.
   * @param options
   */


  static async tryCreate(options = {}) {
    try {
      const obj = new this(options);
      await obj.init();
      return obj;
    } catch (ex) {
      if (ex.message == "E_DB_NO_OBJECT") {
        return null;
      } else {
        throw ex;
      }
    }
  }
  /** Creates a new database record, populating it from the fields list
   * @param {Object} fields
   * @param {Object} [options] - options for database creation
   * @returns {DbRecord} the newly created object
   */


  static async newRecord(fields, options = {}) {
    const obj = new this();
    await obj.init();
    Object.keys(fields).forEach(k => {
      obj._changes[k] = true;
      obj._raw[k] = fields[k];
    });
    await obj.commit({
      behavior: "INSERT"
    });
    return obj;
  }
  /**
   * Save accumulated changed fields, if any
   * @param {Object} options
   * @param {"REPLACE"|"INSERT"} options.behavior - if "REPLACE", does "REPLACE INTO".
   * 	"INSERT" forces to try inserting the record, regardless of _locateField
   * 	existance.
   */


  async commit(options = {}) {
    let sql = "";

    if (Object.keys(this._changes).length === 0) {
      return;
    }

    if (this._raw[this._locateField] !== undefined && options.behavior !== "INSERT") {
      sql = "UPDATE ";
    } else if (options.behavior === "REPLACE") {
      sql = "REPLACE INTO ";
    } else {
      sql = "INSERT INTO ";
    }

    sql += `${this._tableName} SET `;
    const fields = [];
    const values = [];
    Object.keys(this._changes).forEach(field => {
      fields.push(field + "=?");
      values.push(this._raw[field]);
    });
    sql += fields.join(",");

    if (this._raw[this._locateField] !== undefined && options.behavior !== "INSERT") {
      sql += ` WHERE ${this._locateField}=?`;
      values.push(this._raw[this._locateField]);
    } // Compare our dbh.cid and current transaction dbh


    const trxDbh = this._getDbhClass().masterDbhRO(); //console.log("Comparing dbh:", this._dbh.cid, trxDbh? trxDbh.cid: undefined);


    if (trxDbh) {
      if (this._dbh.cid !== trxDbh.cid) {
        throw new Error(`${this.constructor.name}: Object has to be re-created in transaction`);
      }
    }

    const res = await this._dbh.queryAsync(sql, values);
    this._changes = {}; // During the first insert the ${_locatefield()} field will be empty, and,
    // probably, generated by mysql

    if (this._raw[this._locateField] === undefined) {
      this._raw[this._locateField] = res.insertId;

      if (this[this._locateField] === undefined) {
        this._createAccessMethod(this._locateField);
      }
    }
  }
  /**
   * Initializes class from the database or as an empty record.
   *
   * If 'options' contains a property named as _locatefield() defines, then we
   * try to initialize from the database. Exception is thrown if there's no
   * record found.
   *
   * @param options
   * @protected
   */


  async _init(options) {
    let byKey = null;
    const keyArgs = [];

    this.constructor._keys().sort(commaSort).forEach(k => {
      // console.log("key", k);
      if (byKey != null) {
        return;
      } // Check if all key parts are present


      let fits = true;
      k.split(",").forEach(kpart => {
        if (!(kpart in options)) {
          fits = false;
        }
      });

      if (fits) {
        // Key fits, remember it and its arguments
        byKey = k.split(",");
        byKey.forEach(kpart => {
          keyArgs.push(options[kpart]);
        });
      }
    }); // if "_locateField" is set, then we need to read our data from the database


    if (this._locateField in options) {
      await this._read(options[this._locateField]);
    } else if (byKey) {
      await this._readByKey(byKey, keyArgs);
    } else {
      // else create a new record: read the table info and build access methods
      await this._initEmpty();
    }
  }
  /**
   * Reads values from the database, puts them into _raw and creates a function
   * to get each value, so we can access fields as:
   * obj.field();
   * obj.field("new value");
   * @protected
   * @param {*} locateValue - the database unique id of the record
   * @param {String} byKey - the field to search on. $_locateField by default.
   */


  async _read(locateValue, byKey) {
    let field = byKey || this._locateField;
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${field}=? LIMIT 1 ${forUpdate}`, [locateValue]);
    return this._createFromRows(rows);
  }
  /**
   * Does the same work as _read, but accepts the secondary keys and values arrays
   * @param keys {Array}
   * @param values {Array}
   * @private
   */


  async _readByKey(keys, values) {
    const fields = keys.join("=? AND ") + "=?";
    const forUpdate = this._options.forUpdate ? "FOR UPDATE" : "";
    const rows = await this._dbh.queryAsync(`SELECT * FROM ${this._tableName} WHERE ${fields} LIMIT 1 ${forUpdate}`, values);
    return this._createFromRows(rows);
  }
  /**
   * Initialize object and methods			if(args.Length >= 1 && !UUID.TryParse(args[0], out folder)) {
  			return "FAIL: error parsing folder UUID";
  		}
   from rows array
   * @param rows
   * @private
   */


  _createFromRows(rows) {
    if (rows.length == 0) {
      throw new Error("E_DB_NO_OBJECT");
    }

    this._raw = rows[0]; // Create access methods for all fields

    Object.keys(this._raw).forEach(field => {
      this._createAccessMethod(field);
    });
  }
  /**
   * Initializes an empty object
   * @private
   */


  async _initEmpty() {
    const rows = await this._dbh.queryAsync(`DESCRIBE ${this._tableName}`);
    rows.forEach(field => {
      this._createAccessMethod(field.Field);
    });
  }
  /**
   * The template for access methods. Reads or sets the value of the object field.
   * @param field
   * @param value
   * @private
   */


  _accessField(field, value) {
    // To set NULL field: class.field(null)
    if (value !== undefined) {
      this._changes[field] = true;
      this._raw[field] = value;
    }

    return this._raw[field];
  }
  /**
   * Creates a function within this class to get/set the certain field
   * @param field
   * @private
   */


  _createAccessMethod(field) {
    //console.log("creating", field, typeof this[field]);
    const f = (value = undefined) => {
      return this._accessField(field, value);
    }; // If access function already exists, do not overwrite it. Instead, add a function
    // to this._super object


    if (typeof this[field] === "function") {
      this._super[field] = f;
    } else {
      this[field] = f;
    }
  }
  /**
   * Removes the record from the database. No verification or integrity checks
   * are being performed, they are up to caller.
   */


  async deleteRecord() {
    await this._dbh.queryAsync(`DELETE FROM ${this._tableName} WHERE ${this._locateField} = ?`, [this[this._locateField]()]);
  }
  /**
   * Returns master database handle currently in-use. To be used in static
   * methods of DbRecord
   *
   * @returns {MysqlDatabase2} current mysql database connection class
   */


  static masterDbh() {
    return this._getDbhClassStatic().masterDbh();
  }
  /**
   * Runs through database objects according the options, and calls the
   * callback routine for each.
   *
   * @param {Object} options
   * @param {String} options.any_lowercase_field - the field to get added to WHERE
   * @param {[String]} options.whereCond - optional WHERE conditions to add
   * @param {[String]} options.whereParam - optional parameters for whereCond's
   * @param {Boolean} [options.forUpdate] - lock records for update
   * @param {String} [options.ORDERBY] - the sort field or expression
   * @param {String} [options.LIMIT] - the SQL LIMIT expression
   * @param {Boolean} [options.DEBUG_SQL_QUERY] - send SQL to console log
   * @param {Function} cb - the callback function, it receives two arguments:
   * 	the current iteration DbRecord and the "options" object
   *
   * @returns {Number} the number of rows found
   */


  static async forEach(options, cb) {
    const where = [];
    const qparam = [];

    const sql = this._prepareForEach(options, where, qparam); //
    // Iterate


    const _dbh = await this._getDbhClassStatic().masterDbh();

    const rows = await _dbh.queryAsync(sql, qparam);
    options.TOTAL = rows.length;

    if (cb) {
      options.COUNTER = 0;

      for (const row of rows) {
        options.COUNTER++;
        const o = {};
        o[this._locatefield()] = row[this._locatefield()];
        const obj = new this(o);
        await obj.init(); // Wait for iterator to end

        await cb(obj, options);
      }
    } else {
      options.COUNTER = options.TOTAL;
    }

    return options.COUNTER;
  }
  /**
   * Prepares SQL and param arrays for forEach()
   * @param options
   * @param where
   * @param qparam
   * @returns {string}
   * @private
   */


  static _prepareForEach(options, where, qparam) {
    let sql = `SELECT ${this._locatefield()} FROM ${this._table()}`;

    if (options.forUpdate) {
      sql += " FOR UPDATE";
    } // WHERE fields


    Object.keys(options).forEach(k => {
      if (k.match(/[^a-z0-9._]/)) {
        return;
      }

      where.push(`${k}=?`);
      qparam.push(options[k]);
    });

    if (options.whereCond) {
      options.whereCond.forEach(q => {
        where.push(`(${q})`);
      });
    }

    if (options.whereParam) {
      options.whereParam.forEach(q => {
        qparam.push(q);
      });
    }

    if (where.length > 0) {
      sql += " WHERE " + where.join(" AND ");
    } // ORDER BY


    if (options.ORDERBY && !options.ORDERBY.match(/[^a-zA-Z0-9 ><-]/)) {
      sql += " ORDER BY " + options.ORDERBY;
    } // LIMIT


    if (options.LIMIT && !options.LIMIT.toString().match(/[^0-9, ]/)) {
      sql += " LIMIT " + options.LIMIT;
    }

    if (options.DEBUG_SQL_QUERY) {
      console.log(sql, qparam);
    }

    return sql;
  }
  /**
   * Starts a transaction and creates an instance of our object within that
   * transaction, passing it to the callback
   * @param {Function} cb - function to run with a "me" newly created objec
   * @returns {Promise<void>}
   */


  async transactionWithMe(cb) {
    const Class = this.constructor; // Make sure we are committed

    if (Object.keys(this._changes).length > 0) {
      throw new Error(`${Class.name}: Object has uncommitted changes before transaction`);
    }

    const dbh = await Class.masterDbh();
    await dbh.execTransactionAsync(async () => {
      const params = {};
      params[this._locateField] = this[this._locateField]();
      const me = new this.constructor(params);
      await me.init();
      return await cb(me);
    }); // Re-read our object after the transaction

    await this._read(this[this._locateField]());
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord class
   * @private
   */


  static _getDbhClassStatic() {
    return _MysqlDatabase.default;
  }
  /**
   * Returns MysqlDatabase class used for this DbRecord object
   * @private
   */


  _getDbhClass() {
    return _MysqlDatabase.default;
  }

}
/**
 * The sorting function to get entries with more commas first
 * @param a
 * @param b
 */


exports.default = DbRecord2;

function commaSort(a, b) {
  const ca = strcount(a, ",");
  const cb = strcount(b, ",");
  return ca > cb ? -1 : 1;
}

module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9EYlJlY29yZDIuanMiXSwibmFtZXMiOlsic3RyY291bnQiLCJyZXF1aXJlIiwiRGJSZWNvcmQyIiwiX3RhYmxlIiwiX2xvY2F0ZWZpZWxkIiwiX2tleXMiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJfcmF3IiwiX2NoYW5nZXMiLCJfc3VwZXIiLCJfdGFibGVOYW1lIiwiX2xvY2F0ZUZpZWxkIiwiX29wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJpbml0IiwiZGJoIiwiX2RiaCIsIl9nZXREYmhDbGFzcyIsIm1hc3RlckRiaCIsIl9pbml0IiwidHJ5Q3JlYXRlIiwib2JqIiwiZXgiLCJtZXNzYWdlIiwibmV3UmVjb3JkIiwiZmllbGRzIiwia2V5cyIsImZvckVhY2giLCJrIiwiY29tbWl0IiwiYmVoYXZpb3IiLCJzcWwiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ2YWx1ZXMiLCJmaWVsZCIsInB1c2giLCJqb2luIiwidHJ4RGJoIiwibWFzdGVyRGJoUk8iLCJjaWQiLCJFcnJvciIsIm5hbWUiLCJyZXMiLCJxdWVyeUFzeW5jIiwiaW5zZXJ0SWQiLCJfY3JlYXRlQWNjZXNzTWV0aG9kIiwiYnlLZXkiLCJrZXlBcmdzIiwic29ydCIsImNvbW1hU29ydCIsImZpdHMiLCJzcGxpdCIsImtwYXJ0IiwiX3JlYWQiLCJfcmVhZEJ5S2V5IiwiX2luaXRFbXB0eSIsImxvY2F0ZVZhbHVlIiwiZm9yVXBkYXRlIiwicm93cyIsIl9jcmVhdGVGcm9tUm93cyIsIkZpZWxkIiwiX2FjY2Vzc0ZpZWxkIiwidmFsdWUiLCJmIiwiZGVsZXRlUmVjb3JkIiwiX2dldERiaENsYXNzU3RhdGljIiwiY2IiLCJ3aGVyZSIsInFwYXJhbSIsIl9wcmVwYXJlRm9yRWFjaCIsIlRPVEFMIiwiQ09VTlRFUiIsInJvdyIsIm8iLCJtYXRjaCIsIndoZXJlQ29uZCIsInEiLCJ3aGVyZVBhcmFtIiwiT1JERVJCWSIsIkxJTUlUIiwidG9TdHJpbmciLCJERUJVR19TUUxfUVVFUlkiLCJjb25zb2xlIiwibG9nIiwidHJhbnNhY3Rpb25XaXRoTWUiLCJDbGFzcyIsImV4ZWNUcmFuc2FjdGlvbkFzeW5jIiwicGFyYW1zIiwibWUiLCJNeXNxbERhdGFiYXNlMiIsImEiLCJiIiwiY2EiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7OztBQUNBLE1BQU1BLFFBQVEsR0FBR0MsT0FBTyxDQUFDLDBCQUFELENBQXhCO0FBRUE7Ozs7O0FBR2UsTUFBTUMsU0FBTixDQUFnQjtBQUM5QixTQUFPQyxNQUFQLEdBQWdCO0FBQUUsVUFBTSxvQ0FBTjtBQUE2Qzs7QUFDL0QsU0FBT0MsWUFBUCxHQUFzQjtBQUFFLFVBQU0sb0NBQU47QUFBNkM7O0FBQ3JFLFNBQU9DLEtBQVAsR0FBZTtBQUFFLFdBQU8sRUFBUDtBQUFZO0FBRTdCOzs7Ozs7Ozs7O0FBUUFDLEVBQUFBLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHLEVBQVgsRUFBZTtBQUN6Qjs7O0FBR0EsU0FBS0MsSUFBTCxHQUFZLEVBQVo7QUFDQSxTQUFLQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEVBQWQsQ0FOeUIsQ0FNUDs7QUFFbEIsU0FBS0MsVUFBTCxHQUFrQixLQUFLTCxXQUFMLENBQWlCSCxNQUFqQixFQUFsQjtBQUNBLFNBQUtTLFlBQUwsR0FBb0IsS0FBS04sV0FBTCxDQUFpQkYsWUFBakIsRUFBcEI7QUFFQSxTQUFLUyxRQUFMLEdBQWdCQyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCUixPQUFsQixDQUFoQjtBQUNBO0FBRUQ7Ozs7OztBQUlBLFFBQU1TLElBQU4sR0FBYTtBQUNaO0FBQ0EsUUFBRyxLQUFLSCxRQUFMLENBQWNJLEdBQWpCLEVBQXNCO0FBQ3JCLFdBQUtDLElBQUwsR0FBWSxLQUFLTCxRQUFMLENBQWNJLEdBQTFCO0FBQ0EsS0FGRCxNQUVPO0FBQ04sV0FBS0MsSUFBTCxHQUFZLE1BQU0sS0FBS0MsWUFBTCxHQUFvQkMsU0FBcEIsRUFBbEI7QUFDQSxLQU5XLENBUVo7OztBQUVBLFVB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QUFDQSxZQUFNK0UsRUFBRSxHQUFHLElBQUksS0FBS3JGLFdBQVQsQ0FBcUJvRixNQUFyQixDQUFYO0FBQ0EsWUFBTUMsRUFBRSxDQUFDM0UsSUFBSCxFQUFOO0FBRUEsYUFBTyxNQUFNcUQsRUFBRSxDQUFDc0IsRUFBRCxDQUFmO0FBQ0EsS0FQSyxDQUFOLENBVDJCLENBa0IzQjs7QUFDQSxVQUFNLEtBQUtuQyxLQUFMLENBQVcsS0FBSyxLQUFLNUMsWUFBVixHQUFYLENBQU47QUFDQTtBQUVEOzs7Ozs7QUFJQSxTQUFPd0Qsa0JBQVAsR0FBNEI7QUFDM0IsV0FBT3dCLHNCQUFQO0FBQ0E7QUFDRDs7Ozs7O0FBSUF6RSxFQUFBQSxZQUFZLEdBQUc7QUFDZCxXQUFPeUUsc0JBQVA7QUFDQTs7QUEvYzZCO0FBbWQvQjs7Ozs7Ozs7O0FBS0EsU0FBU3hDLFNBQVQsQ0FBbUJ5QyxDQUFuQixFQUFxQkMsQ0FBckIsRUFBd0I7QUFDdkIsUUFBTUMsRUFBRSxHQUFHL0YsUUFBUSxDQUFDNkYsQ0FBRCxFQUFJLEdBQUosQ0FBbkI7QUFDQSxRQUFNeEIsRUFBRSxHQUFHckUsUUFBUSxDQUFDOEYsQ0FBRCxFQUFJLEdBQUosQ0FBbkI7QUFDQSxTQUFPQyxFQUFFLEdBQUMxQixFQUFILEdBQU8sQ0FBQyxDQUFSLEdBQVksQ0FBbkI7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNeXNxbERhdGFiYXNlMiBmcm9tIFwiLi9NeXNxbERhdGFiYXNlMlwiO1xuY29uc3Qgc3RyY291bnQgPSByZXF1aXJlKCdxdWlja2x5LWNvdW50LXN1YnN0cmluZ3MnKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkYXRhYmFzZSByZWNvcmQgY2xhc3MuXG4qKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERiUmVjb3JkMiB7XG5cdHN0YXRpYyBfdGFibGUoKSB7IHRocm93IFwiRGJSZWNvcmQgY2FuJ3QgYmUgY3JlYXRlZCBkaXJlY3RseVwiOyB9XG5cdHN0YXRpYyBfbG9jYXRlZmllbGQoKSB7IHRocm93IFwiRGJSZWNvcmQgY2FuJ3QgYmUgY3JlYXRlZCBkaXJlY3RseVwiOyB9XG5cdHN0YXRpYyBfa2V5cygpIHsgcmV0dXJuIFtdOyB9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIGNsYXNzIGluc3RhbmNlLiBJZiBvcHRpb25zLiR7X2xvY2F0ZWZpZWxkKCl9IHBhcmFtZXRlciBpcyBzcGVjaWZpZWQsXG5cdCAqIHJlYWRzIHRoZSBkYXRhIGZyb20gdGhlIGRhdGFiYXNlIGFuZCBwdXQgdGhlbSBpbnRvIHRoZSBpbnRlcm5hbCBzdHJ1Y3R1cmVzXG5cdCAqIChzZWUgX2luaXQoKSBhbmQgX3JlYWQoKSlcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvclVwZGF0ZV0gLSByZWFkIHJlY29yZCB3aXRoIEZPUiBVUERBVEUgZmxhZyxcblx0ICogXHRibG9ja2luZyBpdCB3aXRoaW4gdGhlIHRyYW5zYWN0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcblx0XHQvKipcblx0XHQgKiBUaGUgZGF0YWJhc2UgaGFuZGxlciB0byB3b3JrIHdpdGhcblx0XHQgKi9cblx0XHR0aGlzLl9yYXcgPSB7fTtcblx0XHR0aGlzLl9jaGFuZ2VzID0ge307XG5cdFx0dGhpcy5fc3VwZXIgPSB7fTsgLy8gVG8gaG9sZCB0aGUgZXhpc3RpbmcgYWNjZXNzIG1ldGhvZCBmdW5jdGlvbnNcblxuXHRcdHRoaXMuX3RhYmxlTmFtZSA9IHRoaXMuY29uc3RydWN0b3IuX3RhYmxlKCk7XG5cdFx0dGhpcy5fbG9jYXRlRmllbGQgPSB0aGlzLmNvbnN0cnVjdG9yLl9sb2NhdGVmaWVsZCgpO1xuXG5cdFx0dGhpcy5fb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgY2xhc3Mgc3RydWN0dXJlcywgcmVhZCBkYXRhYmFzZVxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIGluaXQoKSB7XG5cdFx0Ly8gVXNlIGVpdGhlciBsb2NhbGx5IHByb3ZpZGVkIG9yIGRhdGFiYXNlIGhhbmRsZXIgZmFjdG9yeVxuXHRcdGlmKHRoaXMuX29wdGlvbnMuZGJoKSB7XG5cdFx0XHR0aGlzLl9kYmggPSB0aGlzLl9vcHRpb25zLmRiaDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZGJoID0gYXdhaXQgdGhpcy5fZ2V0RGJoQ2xhc3MoKS5tYXN0ZXJEYmgoKTtcblx0XHR9XG5cblx0XHQvL2NvbnNvbGUubG9nKFwidXNpbmcgdHJ4RGJoOlwiLCB0aGlzLl9kYmguY2lkKTtcblxuXHRcdGF3YWl0IHRoaXMuX2luaXQodGhpcy5fb3B0aW9ucyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBUcmllcyBjcmVhdGluZyBhbiBvYmplY3QgYnkgbG9jYXRlIGZpZWxkL2tleXMuIFVubGlrZSBjb25zdHJ1Y3RvciwgZG9lc1xuXHQgKiBub3QgdGhyb3cgYW4gZXJyb3IgZm9yIG5vbi1leGlzdGluZyByZWNvcmQgYW5kIHJldHVybnMgbnVsbCBpbnN0ZWFkLlxuXHQgKiBAcGFyYW0gb3B0aW9uc1xuXHQgKi9cblx0c3RhdGljIGFzeW5jIHRyeUNyZWF0ZShvcHRpb25zID0ge30pIHtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3Qgb2JqID0gbmV3IHRoaXMob3B0aW9ucyk7XG5cdFx0XHRhd2FpdCBvYmouaW5pdCgpO1xuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9IGNhdGNoKGV4KSB7XG5cdFx0XHRpZihleC5tZXNzYWdlID09IFwiRV9EQl9OT19PQkpFQ1RcIikgeyByZXR1cm4gbnVsbDsgfVxuXHRcdFx0ZWxzZSB7IHRocm93IGV4OyB9XG5cdFx0fVxuXHR9XG5cblx0LyoqIENyZWF0ZXMgYSBuZXcgZGF0YWJhc2UgcmVjb3JkLCBwb3B1bGF0aW5nIGl0IGZyb20gdGhlIGZpZWxkcyBsaXN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmaWVsZHNcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIG9wdGlvbnMgZm9yIGRhdGFiYXNlIGNyZWF0aW9uXG5cdCAqIEByZXR1cm5zIHtEYlJlY29yZH0gdGhlIG5ld2x5IGNyZWF0ZWQgb2JqZWN0XG5cdCAqL1xuXHRzdGF0aWMgYXN5bmMgbmV3UmVjb3JkKGZpZWxkcywgb3B0aW9ucyA9IHt9KSB7XG5cdFx0Y29uc3Qgb2JqID0gbmV3IHRoaXMoKTtcblx0XHRhd2FpdCBvYmouaW5pdCgpO1xuXG5cdFx0T2JqZWN0LmtleXMoZmllbGRzKS5mb3JFYWNoKChrKSA9PiB7XG5cdFx0XHRvYmouX2NoYW5nZXNba10gPSB0cnVlO1xuXHRcdFx0b2JqLl9yYXdba10gPSBmaWVsZHNba107XG5cdFx0fSk7XG5cblx0XHRhd2FpdCBvYmouY29tbWl0KHsgYmVoYXZpb3I6IFwiSU5TRVJUXCIgfSk7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlIGFjY3VtdWxhdGVkIGNoYW5nZWQgZmllbGRzLCBpZiBhbnlcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHBhcmFtIHtcIlJFUExBQ0VcInxcIklOU0VSVFwifSBvcHRpb25zLmJlaGF2aW9yIC0gaWYgXCJSRVBMQUNFXCIsIGRvZXMgXCJSRVBMQUNFIElOVE9cIi5cblx0ICogXHRcIklOU0VSVFwiIGZvcmNlcyB0byB0cnkgaW5zZXJ0aW5nIHRoZSByZWNvcmQsIHJlZ2FyZGxlc3Mgb2YgX2xvY2F0ZUZpZWxkXG5cdCAqIFx0ZXhpc3RhbmNlLlxuXHQgKi9cblx0YXN5bmMgY29tbWl0KG9wdGlvbnMgPSB7fSkge1xuXHRcdGxldCBzcWwgPSBcIlwiO1xuXG5cdFx0aWYoT2JqZWN0LmtleXModGhpcy5fY2hhbmdlcykubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYodGhpcy5fcmF3W3RoaXMuX2xvY2F0ZUZpZWxkXSAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuYmVoYXZpb3IgIT09IFwiSU5TRVJUXCIpIHtcblx0XHRcdHNxbCA9IFwiVVBEQVRFIFwiO1xuXHRcdH0gZWxzZSBpZihvcHRpb25zLmJlaGF2aW9yID09PSBcIlJFUExBQ0VcIikge1xuXHRcdFx0c3FsID0gXCJSRVBMQUNFIElOVE8gXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHNxbCA9IFwiSU5TRVJUIElOVE8gXCI7XG5cdFx0fVxuXG5cdFx0c3FsICs9IGAke3RoaXMuX3RhYmxlTmFtZX0gU0VUIGA7XG5cdFx0Y29uc3QgZmllbGRzID0gW107XG5cdFx0Y29uc3QgdmFsdWVzID0gW107XG5cdFx0T2JqZWN0LmtleXModGhpcy5fY2hhbmdlcykuZm9yRWFjaCgoZmllbGQpID0+IHtcblx0XHRcdGZpZWxkcy5wdXNoKGZpZWxkICsgXCI9P1wiKTtcblx0XHRcdHZhbHVlcy5wdXNoKHRoaXMuX3Jhd1tmaWVsZF0pO1xuXHRcdH0pO1xuXG5cdFx0c3FsICs9IGZpZWxkcy5qb2luKFwiLFwiKTtcblxuXHRcdGlmKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0gIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmJlaGF2aW9yICE9PSBcIklOU0VSVFwiKSB7XG5cdFx0XHRzcWwgKz0gYCBXSEVSRSAke3RoaXMuX2xvY2F0ZUZpZWxkfT0/YDtcblx0XHRcdHZhbHVlcy5wdXNoKHRoaXMuX3Jhd1t0aGlzLl9sb2NhdGVGaWVsZF0pO1xuXHRcdH1cblxuXHRcdC8vIENvbXBhcmUgb3VyIGRiaC5jaWQgYW5kIGN1cnJlbnQgdHJhbnNhY3Rpb24gZGJoXG5cdFx0Y29uc3QgdHJ4RGJoID0gdGhpcy5fZ2V0RGJoQ2xhc3MoKS5tYXN0ZXJEYmhSTygpO1xuXG5cdFx0Ly9jb25zb2xlLmxvZyhcIkNvbXBhcmluZyBkYmg6XCIsIHRoaXMuX2RiaC5jaWQsIHRyeERiaD8gdHJ4RGJoLmNpZDogdW5kZWZpbmVkKTtcblxuXHRcdGlmKHRyeERiaCkge1xuXHRcdFx0aWYodGhpcy5fZGJoLmNpZCAhPT0gdHJ4RGJoLmNpZCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfTogT2JqZWN0IGhhcyB0byBiZSByZS1jcmVhdGVkIGluIHRyYW5zYWN0aW9uYCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoVEFSR0VUID09PSBcImRldmVsb3BtZW50XCIpIHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGAke3RoaXMuX2RiaC5fZGIudGhyZWFkSWR9OiBpbiBjb21taXQgYmVmb3JlIHF1ZXJ5YCk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoc3FsLCB2YWx1ZXMpO1xuXG5cdFx0dGhpcy5fY2hhbmdlcyA9IHt9O1xuXG5cdFx0Ly8gRHVyaW5nIHRoZSBmaXJzdCBpbnNlcnQgdGhlICR7X2xvY2F0ZWZpZWxkKCl9IGZpZWxkIHdpbGwgYmUgZW1wdHksIGFuZCxcblx0XHQvLyBwcm9iYWJseSwgZ2VuZXJhdGVkIGJ5IG15c3FsXG5cdFx0aWYodGhpcy5fcmF3W3RoaXMuX2xvY2F0ZUZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9yYXdbdGhpcy5fbG9jYXRlRmllbGRdID0gcmVzLmluc2VydElkO1xuXG5cdFx0XHRpZih0aGlzW3RoaXMuX2xvY2F0ZUZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMuX2NyZWF0ZUFjY2Vzc01ldGhvZCh0aGlzLl9sb2NhdGVGaWVsZCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIGNsYXNzIGZyb20gdGhlIGRhdGFiYXNlIG9yIGFzIGFuIGVtcHR5IHJlY29yZC5cblx0ICpcblx0ICogSWYgJ29wdGlvbnMnIGNvbnRhaW5zIGEgcHJvcGVydHkgbmFtZWQgYXMgX2xvY2F0ZWZpZWxkKCkgZGVmaW5lcywgdGhlbiB3ZVxuXHQgKiB0cnkgdG8gaW5pdGlhbGl6ZSBmcm9tIHRoZSBkYXRhYmFzZS4gRXhjZXB0aW9uIGlzIHRocm93biBpZiB0aGVyZSdzIG5vXG5cdCAqIHJlY29yZCBmb3VuZC5cblx0ICpcblx0ICogQHBhcmFtIG9wdGlvbnNcblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0YXN5bmMgX2luaXQob3B0aW9ucykge1xuXHRcdGxldCBieUtleSA9IG51bGw7XG5cdFx0Y29uc3Qga2V5QXJncyA9IFtdO1xuXG5cdFx0dGhpcy5jb25zdHJ1Y3Rvci5fa2V5cygpLnNvcnQoY29tbWFTb3J0KS5mb3JFYWNoKChrKSA9PiB7XG5cdFx0XHQvLyBjb25zb2xlLmxvZyhcImtleVwiLCBrKTtcblx0XHRcdGlmKGJ5S2V5ICE9IG51bGwpIHsgcmV0dXJuOyB9XG5cblx0XHRcdC8vIENoZWNrIGlmIGFsbCBrZXkgcGFydHMgYXJlIHByZXNlbnRcblx0XHRcdGxldCBmaXRzID0gdHJ1ZTtcblx0XHRcdGsuc3BsaXQoXCIsXCIpLmZvckVhY2goKGtwYXJ0KSA9PiB7XG5cdFx0XHRcdGlmKCEoa3BhcnQgaW4gb3B0aW9ucykpIHsgZml0cyA9IGZhbHNlOyB9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYoZml0cykge1xuXHRcdFx0XHQvLyBLZXkgZml0cywgcmVtZW1iZXIgaXQgYW5kIGl0cyBhcmd1bWVudHNcblx0XHRcdFx0YnlLZXkgPSBrLnNwbGl0KFwiLFwiKTtcblx0XHRcdFx0YnlLZXkuZm9yRWFjaCgoa3BhcnQpID0+IHtcblx0XHRcdFx0XHRrZXlBcmdzLnB1c2gob3B0aW9uc1trcGFydF0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIGlmIFwiX2xvY2F0ZUZpZWxkXCIgaXMgc2V0LCB0aGVuIHdlIG5lZWQgdG8gcmVhZCBvdXIgZGF0YSBmcm9tIHRoZSBkYXRhYmFzZVxuXHRcdGlmKHRoaXMuX2xvY2F0ZUZpZWxkIGluIG9wdGlvbnMpIHtcblx0XHRcdGF3YWl0IHRoaXMuX3JlYWQob3B0aW9uc1t0aGlzLl9sb2NhdGVGaWVsZF0pO1xuXHRcdH1cblx0XHRlbHNlIGlmKGJ5S2V5KSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9yZWFkQnlLZXkoYnlLZXksIGtleUFyZ3MpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGVsc2UgY3JlYXRlIGEgbmV3IHJlY29yZDogcmVhZCB0aGUgdGFibGUgaW5mbyBhbmQgYnVpbGQgYWNjZXNzIG1ldGhvZHNcblx0XHRcdGF3YWl0IHRoaXMuX2luaXRFbXB0eSgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWFkcyB2YWx1ZXMgZnJvbSB0aGUgZGF0YWJhc2UsIHB1dHMgdGhlbSBpbnRvIF9yYXcgYW5kIGNyZWF0ZXMgYSBmdW5jdGlvblxuXHQgKiB0byBnZXQgZWFjaCB2YWx1ZSwgc28gd2UgY2FuIGFjY2VzcyBmaWVsZHMgYXM6XG5cdCAqIG9iai5maWVsZCgpO1xuXHQgKiBvYmouZmllbGQoXCJuZXcgdmFsdWVcIik7XG5cdCAqIEBwcm90ZWN0ZWRcblx0ICogQHBhcmFtIHsqfSBsb2NhdGVWYWx1ZSAtIHRoZSBkYXRhYmFzZSB1bmlxdWUgaWQgb2YgdGhlIHJlY29yZFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gYnlLZXkgLSB0aGUgZmllbGQgdG8gc2VhcmNoIG9uLiAkX2xvY2F0ZUZpZWxkIGJ5IGRlZmF1bHQuXG5cdCAqL1xuXHRhc3luYyBfcmVhZChsb2NhdGVWYWx1ZSwgYnlLZXkpIHtcblx0XHRsZXQgZmllbGQgPSBieUtleSB8fCB0aGlzLl9sb2NhdGVGaWVsZDtcblx0XHRjb25zdCBmb3JVcGRhdGUgPSB0aGlzLl9vcHRpb25zLmZvclVwZGF0ZT8gXCJGT1IgVVBEQVRFXCI6IFwiXCI7XG5cblx0XHRjb25zdCByb3dzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYFNFTEVDVCAqIEZST00gJHt0aGlzLl90YWJsZU5hbWV9IFdIRVJFICR7ZmllbGR9PT8gTElNSVQgMSAke2ZvclVwZGF0ZX1gLFxuXHRcdFx0W2xvY2F0ZVZhbHVlXSk7XG5cdFx0cmV0dXJuIHRoaXMuX2NyZWF0ZUZyb21Sb3dzKHJvd3MpO1xuXHR9XG5cblxuXHQvKipcblx0ICogRG9lcyB0aGUgc2FtZSB3b3JrIGFzIF9yZWFkLCBidXQgYWNjZXB0cyB0aGUgc2Vjb25kYXJ5IGtleXMgYW5kIHZhbHVlcyBhcnJheXNcblx0ICogQHBhcmFtIGtleXMge0FycmF5fVxuXHQgKiBAcGFyYW0gdmFsdWVzIHtBcnJheX1cblx0ICogQHByaXZhdGVcblx0ICovXG5cdGFzeW5jIF9yZWFkQnlLZXkoa2V5cywgdmFsdWVzKSB7XG5cdFx0Y29uc3QgZmllbGRzID0ga2V5cy5qb2luKFwiPT8gQU5EIFwiKSArIFwiPT9cIjtcblx0XHRjb25zdCBmb3JVcGRhdGUgPSB0aGlzLl9vcHRpb25zLmZvclVwZGF0ZT8gXCJGT1IgVVBEQVRFXCI6IFwiXCI7XG5cblx0XHRjb25zdCByb3dzID0gYXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYFNFTEVDVCAqIEZST00gJHt0aGlzLl90YWJsZU5hbWV9IFdIRVJFICR7ZmllbGRzfSBMSU1JVCAxICR7Zm9yVXBkYXRlfWAsXG5cdFx0XHR2YWx1ZXMpO1xuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVGcm9tUm93cyhyb3dzKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgb2JqZWN0IGFuZCBtZXRob2RzXHRcdFx0aWYoYXJncy5MZW5ndGggPj0gMSAmJiAhVVVJRC5UcnlQYXJzZShhcmdzWzBdLCBvdXQgZm9sZGVyKSkge1xuXHRcdFx0XHRyZXR1cm4gXCJGQUlMOiBlcnJvciBwYXJzaW5nIGZvbGRlciBVVUlEXCI7XG5cdFx0XHR9XG5cdCBmcm9tIHJvd3MgYXJyYXlcblx0ICogQHBhcmFtIHJvd3Ncblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9jcmVhdGVGcm9tUm93cyhyb3dzKSB7XG5cdFx0aWYocm93cy5sZW5ndGggPT0gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRV9EQl9OT19PQkpFQ1RcIik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmF3ID0gcm93c1swXTtcblxuXHRcdC8vIENyZWF0ZSBhY2Nlc3MgbWV0aG9kcyBmb3IgYWxsIGZpZWxkc1xuXHRcdE9iamVjdC5rZXlzKHRoaXMuX3JhdykuZm9yRWFjaCgoZmllbGQpID0+IHsgdGhpcy5fY3JlYXRlQWNjZXNzTWV0aG9kKGZpZWxkKTsgfSk7XG5cdH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgYW4gZW1wdHkgb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRhc3luYyBfaW5pdEVtcHR5KCkge1xuXHRcdGNvbnN0IHJvd3MgPSBhd2FpdCB0aGlzLl9kYmgucXVlcnlBc3luYyhgREVTQ1JJQkUgJHt0aGlzLl90YWJsZU5hbWV9YCk7XG5cdFx0cm93cy5mb3JFYWNoKChmaWVsZCkgPT4geyB0aGlzLl9jcmVhdGVBY2Nlc3NNZXRob2QoZmllbGQuRmllbGQpOyB9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgdGVtcGxhdGUgZm9yIGFjY2VzcyBtZXRob2RzLiBSZWFkcyBvciBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgb2JqZWN0IGZpZWxkLlxuXHQgKiBAcGFyYW0gZmllbGRcblx0ICogQHBhcmFtIHZhbHVlXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYWNjZXNzRmllbGQoZmllbGQsIHZhbHVlKSB7XG5cdFx0Ly8gVG8gc2V0IE5VTEwgZmllbGQ6IGNsYXNzLmZpZWxkKG51bGwpXG5cdFx0aWYodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fY2hhbmdlc1tmaWVsZF0gPSB0cnVlO1xuXHRcdFx0dGhpcy5fcmF3W2ZpZWxkXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9yYXdbZmllbGRdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBmdW5jdGlvbiB3aXRoaW4gdGhpcyBjbGFzcyB0byBnZXQvc2V0IHRoZSBjZXJ0YWluIGZpZWxkXG5cdCAqIEBwYXJhbSBmaWVsZFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZUFjY2Vzc01ldGhvZChmaWVsZCkge1xuXHRcdC8vY29uc29sZS5sb2coXCJjcmVhdGluZ1wiLCBmaWVsZCwgdHlwZW9mIHRoaXNbZmllbGRdKTtcblx0XHRjb25zdCBmID0gKHZhbHVlID0gdW5kZWZpbmVkKSA9PiB7IHJldHVybiB0aGlzLl9hY2Nlc3NGaWVsZChmaWVsZCwgdmFsdWUpOyB9O1xuXG5cdFx0Ly8gSWYgYWNjZXNzIGZ1bmN0aW9uIGFscmVhZHkgZXhpc3RzLCBkbyBub3Qgb3ZlcndyaXRlIGl0LiBJbnN0ZWFkLCBhZGQgYSBmdW5jdGlvblxuXHRcdC8vIHRvIHRoaXMuX3N1cGVyIG9iamVjdFxuXHRcdGlmKHR5cGVvZiB0aGlzW2ZpZWxkXSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHR0aGlzLl9zdXBlcltmaWVsZF0gPSBmO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzW2ZpZWxkXSA9IGY7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogUmVtb3ZlcyB0aGUgcmVjb3JkIGZyb20gdGhlIGRhdGFiYXNlLiBObyB2ZXJpZmljYXRpb24gb3IgaW50ZWdyaXR5IGNoZWNrc1xuXHQgKiBhcmUgYmVpbmcgcGVyZm9ybWVkLCB0aGV5IGFyZSB1cCB0byBjYWxsZXIuXG5cdCAqL1xuXHRhc3luYyBkZWxldGVSZWNvcmQoKSB7XG5cdFx0YXdhaXQgdGhpcy5fZGJoLnF1ZXJ5QXN5bmMoYERFTEVURSBGUk9NICR7dGhpcy5fdGFibGVOYW1lfSBXSEVSRSAke3RoaXMuX2xvY2F0ZUZpZWxkfSA9ID9gLFxuXHRcdFx0WyB0aGlzW3RoaXMuX2xvY2F0ZUZpZWxkXSgpIF0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgbWFzdGVyIGRhdGFiYXNlIGhhbmRsZSBjdXJyZW50bHkgaW4tdXNlLiBUbyBiZSB1c2VkIGluIHN0YXRpY1xuXHQgKiBtZXRob2RzIG9mIERiUmVjb3JkXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtNeXNxbERhdGFiYXNlMn0gY3VycmVudCBteXNxbCBkYXRhYmFzZSBjb25uZWN0aW9uIGNsYXNzXG5cdCAqL1xuXHRzdGF0aWMgbWFzdGVyRGJoKCkge1xuXHRcdHJldHVybiB0aGlzLl9nZXREYmhDbGFzc1N0YXRpYygpLm1hc3RlckRiaCgpO1xuXHR9XG5cblxuXG5cdC8qKlxuXHQgKiBSdW5zIHRocm91Z2ggZGF0YWJhc2Ugb2JqZWN0cyBhY2NvcmRpbmcgdGhlIG9wdGlvbnMsIGFuZCBjYWxscyB0aGVcblx0ICogY2FsbGJhY2sgcm91dGluZSBmb3IgZWFjaC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYW55X2xvd2VyY2FzZV9maWVsZCAtIHRoZSBmaWVsZCB0byBnZXQgYWRkZWQgdG8gV0hFUkVcblx0ICogQHBhcmFtIHtbU3RyaW5nXX0gb3B0aW9ucy53aGVyZUNvbmQgLSBvcHRpb25hbCBXSEVSRSBjb25kaXRpb25zIHRvIGFkZFxuXHQgKiBAcGFyYW0ge1tTdHJpbmddfSBvcHRpb25zLndoZXJlUGFyYW0gLSBvcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB3aGVyZUNvbmQnc1xuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvclVwZGF0ZV0gLSBsb2NrIHJlY29yZHMgZm9yIHVwZGF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuT1JERVJCWV0gLSB0aGUgc29ydCBmaWVsZCBvciBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5MSU1JVF0gLSB0aGUgU1FMIExJTUlUIGV4cHJlc3Npb25cblx0ICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ERUJVR19TUUxfUVVFUlldIC0gc2VuZCBTUUwgdG8gY29uc29sZSBsb2dcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIGl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG5cdCAqIFx0dGhlIGN1cnJlbnQgaXRlcmF0aW9uIERiUmVjb3JkIGFuZCB0aGUgXCJvcHRpb25zXCIgb2JqZWN0XG5cdCAqXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyBmb3VuZFxuXHQgKi9cblx0c3RhdGljIGFzeW5jIGZvckVhY2gob3B0aW9ucywgY2IpIHtcblx0XHRjb25zdCB3aGVyZSA9IFtdO1xuXHRcdGNvbnN0IHFwYXJhbSA9IFtdO1xuXHRcdGNvbnN0IHNxbCA9IHRoaXMuX3ByZXBhcmVGb3JFYWNoKG9wdGlvbnMsIHdoZXJlLCBxcGFyYW0pO1xuXG5cdFx0Ly9cblx0XHQvLyBJdGVyYXRlXG5cdFx0Y29uc3QgX2RiaCA9IGF3YWl0IHRoaXMuX2dldERiaENsYXNzU3RhdGljKCkubWFzdGVyRGJoKCk7XG5cblx0XHRpZihUQVJHRVQgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuXHRcdFx0Y29uc29sZS5sb2coYCR7X2RiaC5fZGIudGhyZWFkSWR9OiB3aWxsIGJlIHJ1bm5pbmcgZm9yRWFjaCBxdWVyeWApO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJvd3MgPSBhd2FpdCBfZGJoLnF1ZXJ5QXN5bmMoc3FsLCBxcGFyYW0pO1xuXHRcdG9wdGlvbnMuVE9UQUwgPSByb3dzLmxlbmd0aDtcblxuXHRcdGlmKGNiKSB7XG5cdFx0XHRvcHRpb25zLkNPVU5URVIgPSAwO1xuXG5cdFx0XHRmb3IoY29uc3Qgcm93IG9mIHJvd3MpIHtcblx0XHRcdFx0b3B0aW9ucy5DT1VOVEVSKys7XG5cblx0XHRcdFx0Y29uc3QgbyA9IHt9O1xuXHRcdFx0XHRvW3RoaXMuX2xvY2F0ZWZpZWxkKCldID0gcm93W3RoaXMuX2xvY2F0ZWZpZWxkKCldO1xuXHRcdFx0XHRjb25zdCBvYmogPSBuZXcgdGhpcyhvKTtcblx0XHRcdFx0YXdhaXQgb2JqLmluaXQoKTtcblxuXHRcdFx0XHQvLyBXYWl0IGZvciBpdGVyYXRvciB0byBlbmRcblx0XHRcdFx0YXdhaXQgY2Iob2JqLCBvcHRpb25zKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0b3B0aW9ucy5DT1VOVEVSID0gb3B0aW9ucy5UT1RBTDtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3B0aW9ucy5DT1VOVEVSO1xuXHR9XG5cblxuXHQvKipcblx0ICogUHJlcGFyZXMgU1FMIGFuZCBwYXJhbSBhcnJheXMgZm9yIGZvckVhY2goKVxuXHQgKiBAcGFyYW0gb3B0aW9uc1xuXHQgKiBAcGFyYW0gd2hlcmVcblx0ICogQHBhcmFtIHFwYXJhbVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0c3RhdGljIF9wcmVwYXJlRm9yRWFjaChvcHRpb25zLCB3aGVyZSwgcXBhcmFtKSB7XG5cdFx0bGV0IHNxbCA9IGBTRUxFQ1QgJHt0aGlzLl9sb2NhdGVmaWVsZCgpfSBGUk9NICR7dGhpcy5fdGFibGUoKX1gO1xuXHRcdGlmKG9wdGlvbnMuZm9yVXBkYXRlKSB7IHNxbCArPSBcIiBGT1IgVVBEQVRFXCI7IH1cblxuXG5cdFx0Ly8gV0hFUkUgZmllbGRzXG5cdFx0T2JqZWN0LmtleXMob3B0aW9ucykuZm9yRWFjaCgoaykgPT4ge1xuXHRcdFx0aWYoay5tYXRjaCgvW15hLXowLTkuX10vKSkgeyByZXR1cm47IH1cblxuXHRcdFx0d2hlcmUucHVzaChgJHtrfT0/YCk7XG5cdFx0XHRxcGFyYW0ucHVzaChvcHRpb25zW2tdKTtcblx0XHR9KTtcblxuXHRcdGlmKG9wdGlvbnMud2hlcmVDb25kKSB7XG5cdFx0XHRvcHRpb25zLndoZXJlQ29uZC5mb3JFYWNoKChxKSA9PiB7XG5cdFx0XHRcdHdoZXJlLnB1c2goYCgke3F9KWApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYob3B0aW9ucy53aGVyZVBhcmFtKSB7XG5cdFx0XHRvcHRpb25zLndoZXJlUGFyYW0uZm9yRWFjaCgocSkgPT4ge1xuXHRcdFx0XHRxcGFyYW0ucHVzaChxKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmKHdoZXJlLmxlbmd0aCA+IDApIHtcblx0XHRcdHNxbCArPSBcIiBXSEVSRSBcIiArIHdoZXJlLmpvaW4oXCIgQU5EIFwiKTtcblx0XHR9XG5cblxuXHRcdC8vIE9SREVSIEJZXG5cdFx0aWYob3B0aW9ucy5PUkRFUkJZICYmICFvcHRpb25zLk9SREVSQlkubWF0Y2goL1teYS16QS1aMC05ID48LV0vKSkge1xuXHRcdFx0c3FsICs9IFwiIE9SREVSIEJZIFwiICsgb3B0aW9ucy5PUkRFUkJZO1xuXHRcdH1cblxuXHRcdC8vIExJTUlUXG5cdFx0aWYob3B0aW9ucy5MSU1JVCAmJiAhb3B0aW9ucy5MSU1JVC50b1N0cmluZygpLm1hdGNoKC9bXjAtOSwgXS8pKSB7XG5cdFx0XHRzcWwgKz0gXCIgTElNSVQgXCIgKyBvcHRpb25zLkxJTUlUO1xuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMuREVCVUdfU1FMX1FVRVJZKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhzcWwsIHFwYXJhbSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNxbDtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHRyYW5zYWN0aW9uIGFuZCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIG91ciBvYmplY3Qgd2l0aGluIHRoYXRcblx0ICogdHJhbnNhY3Rpb24sIHBhc3NpbmcgaXQgdG8gdGhlIGNhbGxiYWNrXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gZnVuY3Rpb24gdG8gcnVuIHdpdGggYSBcIm1lXCIgbmV3bHkgY3JlYXRlZCBvYmplY1xuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cblx0ICovXG5cdGFzeW5jIHRyYW5zYWN0aW9uV2l0aE1lKGNiKSB7XG5cdFx0Y29uc3QgQ2xhc3MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIGFyZSBjb21taXR0ZWRcblx0XHRpZihPYmplY3Qua2V5cyh0aGlzLl9jaGFuZ2VzKS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7Q2xhc3MubmFtZX06IE9iamVjdCBoYXMgdW5jb21taXR0ZWQgY2hhbmdlcyBiZWZvcmUgdHJhbnNhY3Rpb25gKTtcblx0XHR9XG5cblx0XHRjb25zdCBkYmggPSBhd2FpdCBDbGFzcy5tYXN0ZXJEYmgoKTtcblx0XHRhd2FpdCBkYmguZXhlY1RyYW5zYWN0aW9uQXN5bmMoYXN5bmMgKCkgPT4ge1xuXHRcdFx0Y29uc3QgcGFyYW1zID0ge307XG5cdFx0XHRwYXJhbXNbdGhpcy5fbG9jYXRlRmllbGRdID0gdGhpc1t0aGlzLl9sb2NhdGVGaWVsZF0oKTtcblx0XHRcdGNvbnN0IG1lID0gbmV3IHRoaXMuY29uc3RydWN0b3IocGFyYW1zKTtcblx0XHRcdGF3YWl0IG1lLmluaXQoKTtcblxuXHRcdFx0cmV0dXJuIGF3YWl0IGNiKG1lKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlLXJlYWQgb3VyIG9iamVjdCBhZnRlciB0aGUgdHJhbnNhY3Rpb25cblx0XHRhd2FpdCB0aGlzLl9yZWFkKHRoaXNbdGhpcy5fbG9jYXRlRmllbGRdKCkpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgTXlzcWxEYXRhYmFzZSBjbGFzcyB1c2VkIGZvciB0aGlzIERiUmVjb3JkIGNsYXNzXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzdGF0aWMgX2dldERiaENsYXNzU3RhdGljKCkge1xuXHRcdHJldHVybiBNeXNxbERhdGFiYXNlMjtcblx0fVxuXHQvKipcblx0ICogUmV0dXJucyBNeXNxbERhdGFiYXNlIGNsYXNzIHVzZWQgZm9yIHRoaXMgRGJSZWNvcmQgb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZ2V0RGJoQ2xhc3MoKSB7XG5cdFx0cmV0dXJuIE15c3FsRGF0YWJhc2UyO1xuXHR9XG59XG5cblxuLyoqXG4gKiBUaGUgc29ydGluZyBmdW5jdGlvbiB0byBnZXQgZW50cmllcyB3aXRoIG1vcmUgY29tbWFzIGZpcnN0XG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqL1xuZnVuY3Rpb24gY29tbWFTb3J0KGEsYikge1xuXHRjb25zdCBjYSA9IHN0cmNvdW50KGEsIFwiLFwiKTtcblx0Y29uc3QgY2IgPSBzdHJjb3VudChiLCBcIixcIik7XG5cdHJldHVybiBjYT5jYj8gLTEgOiAxO1xufVxuIl19